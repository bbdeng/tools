## **理解ES**
1. 全称: ECMAScript
2. js语言的规范
3. 我们用的js是它的实现
4. js的组成
  * ECMAScript(js基础)
  * 扩展-->浏览器端
    * BOM
    * DOM
  * 扩展-->服务器端
    * Node.js
      
## ES5
1. **严格模式**
  * 运行模式: 正常(混杂)模式与严格模式
  * 应用上严格式: 'strict mode';
  - 作用: 
    * 使得Javascript在更严格的条件下运行
    * 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为
    * 消除代码运行的一些不安全之处，保证代码运行的安全
  - 使用
  * 在全局或函数的第一条语句定义为: 'use strict';
  * 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用
  - 语法和行为改变
    * 需要记住的几个变化
      * 声明定义变量必须用var
      * 禁止自定义的函数中的this关键字指向全局对象
      * 创建eval作用域, 更安全
      * 对象不能有重名的属性
2. **JSON对象**
  * 作用: 用于在json对象/数组与js对象/数组相互转换
  * JSON.stringify(obj/arr)
      js对象(数组)转换为json对象(数组)
  * JSON.parse(json)
      json对象(数组)转换为js对象(数组)
3. Object扩展
  * Object.create(prototype[, descriptors]) : 创建一个新的对象
    * 以指定对象为原型创建新的对象
    * 指定新的属性, 并对属性进行描述
      * value : 指定值
      * writable : 标识当前属性值是否是可修改的, 默认为true
      * configurable: 标识当前属性是否可以被删除 默认为false
      * enumerable： 标识当前属性是否能用for in 枚举 默认为false
      例子
      var obj = {name : 'curry', age : 29}
      var obj1 = {};
      obj1 = Object.create(obj, {
          sex : {
              value : '男',
              writable : true
          }
      });
      obj1.sex = '女';
      console.log(obj1.sex);

  * Object.defineProperties(object, descriptors) : 为指定对象定义扩展多个属性
      * **get方法** : 用来得到当前属性值的回调函数，获取扩展属性值get方法自动调用
      * **set方法** : 用来监视当前属性值变化的回调函数，自动调用后会将变化的值作为实参传递

      例子：
      var obj2 = {
          firstName : 'curry',
          lastName : 'stephen'
      };
      Object.defineProperties(obj2, {
          fullName : {
              get : function () {
                  return this.firstName + '-' + this.lastName
              },
              set : function (data) {
                  var names = data.split('-');
                  this.firstName = names[0];
                  this.lastName = names[1];
              }
          }
      });
      console.log(obj2.fullName);  //curry-stephen
      obj2.firstName = 'tim';
      obj2.lastName = 'duncan';
      console.log(obj2.fullName);  //tim-duncan
      obj2.fullName = 'kobe-bryant';
      console.log(obj2.fullName);  //kobe-bryant
    * 对象原本本身就有get和set方法
      例子
      var obj = {
          firstName : 'kobe',
          lastName : 'bryant',
          get fullName(){
              return this.firstName + ' ' + this.lastName
          },
          set fullName(data){
              var names = data.split(' ');
              this.firstName = names[0];
              this.lastName = names[1];
          }
      };
      console.log(obj.fullName);
      obj.fullName = 'curry stephen';
      console.log(obj.fullName);
4. Array扩展
  * Array.prototype.indexOf(value) : 得到值在数组中的第一个下标
  * Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标
  * **Array.prototype.forEach(function(item, index){}) : 遍历数组**
  * **Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组**
  * **Array.prototype.filter(function(item, index){}) : 遍历过滤出一个子数组**
5.Function扩展
  1. Function.prototype.bind(obj) :
    * 作用: 将函数内的this绑定为obj, 并将函数返回,不自动调用，主要用于回调函数修改this
  2. 面试题: 区别bind()与call()和apply()?
    * 都能指定函数中的this
    * call()/apply()是立即调用函数,apply()传参数，第1个参数修改this，第2个参数为一个数组
    * bind()是将函数返回
6. Date扩展
  * Date.now() : 得到当前时间值

## ES6
1. **2个新的关键字**
  * let/const
  * const定义常量用的，不可以修改。
  * 块作用域 (循环遍历加监听)
  * 没有变量提升
  * 不能重复定义
  * 值不可变
2. **变量的解构赋值**
  - 理解
    * 从对象或数组中提取数据, 并赋值给变量(多个)
  - 对象的解构赋值
    * let {n, a} = {n:'tom', a:12}
    * console.log(n,a)
  - 数组的解构赋值
    * let [,,a,b] = [1,2,3,3, 'atguigu'];
    * console.log(a,b)  // 3  3  

  - 应用
    let obj = {name : 'kobe', age : 39};
    function person1({name, age}) {
       console.log(name, age);
    }
    person1(obj);
3. 模板字符串 : 简化字符串的拼接
  * 模板字符串必须用 `` 包含
  * 变化的部分使用${xxx}定义
  例子
  let obj = {
        name : 'anverson',
        age : 41
    };
  console.log(`我叫:${obj.name}, 我的年龄是：${obj.age}`);
4. **简化的对象写法**
  * 同名的属性可以简化不写
  * 可以省略函数中的function
  普通额写法
  let x = 3;
  let y = 5;
  let obj = {
       x : x,
       y : y,
       getPoint : function () {
           return this.x + this.y
       }
  };
  简化的写法
  let obj = {
        x,
        y,
        getPoint(){
            return this.x
        }
  };

5. 箭头函数
  - 作用 : 定义匿名函数,多用来定义回调函数
  - 基本语法
    * 没有形参，并且函数体只有一条语句,括号必须写
      let fun1 = () => console.log('fun1()');
    * 一个形参，并且函数体只有一条语句
      let fun2 = x => x;
    * 形参是一个以上
      let fun3 = (x, y) => x + y;
    * 函数体有多条语句,加{}
      let fun4 = (x, y) => {
        console.log(x, y);
        return x + y;
      };
  - 特点
    * 函数体不用大括号: 相当于return整个表达式或语句
    * 函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回
    * 箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this
      * 箭头函数的this看外层的是否有函数，
      * 如果有，外层函数的this就是内部箭头函数的this，
      * 如果没有，则this是window。

6.3点运算符
  * 可以分解出数组或对象中的数据
  - 用途
  1. rest(可变)参数
    * 用来取代arguments 但比arguments灵活,只能是最后部分形参参数
    function fun(...values) {
        console.log(arguments);  //arguments伪数组
        console.log(values);     //values真数组
        values.forEach(function (item, index) {
            console.log(item, index);
        })
    }
    fun(1,2,3);
  2. 扩展运算符
   let arr = [2,3,4,5,6];
   let arr1 = ['abc',...arr, 'fg'];
   console.log(arr1);

7.形参默认值
  function Point(x=12, y=12) {
        this.x = x;
        this.y = y;
  }
  let point = new Point(25, 36);
  console.log(point);   //传入值属性 x y 为传入的值
  let p = new Point();
  console.log(p);    // 未传入值属性值默认为 12 12 


















