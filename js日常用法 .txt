JS是一门轻量级的脚本“编程语言”(HTML+CSS不属于编程语言，属于标记语言)
其他的编程语言：.net C# php Java c c++ vb vf object-c ...
所有的编程语言都是面向对象开发的-->类的继承、封装、多态
继承：子类继承父类中的属性和方法
封装：把实现同一件事情的相同的代码放到一个函数中，以后如果在想实现这个功能，不需要从新编写这些代码，只需要执行当前的函数即可
多态：当前方法的多种形态-->后台语言中：多态包含重载(重载就是相同函数名，可以执行出不同效果;js不存在重载，虽然有类似重载的操作，可以在函数内部对传参数进行判断后执行不同效果，js中方法名一样的话会被后门的覆盖掉)和重写(子类重写父类的方法)

1.警告 alert(""); 
2.页面输出内容 document.write("");
3.向控制台输出console.log("");
4.变量赋值  var a=1243;
5.标识符规则 自主命名都可称标识符 
   规则： 1.含字母、数字、_、&
	  2.不能用数字开头
	  3.不能是ES中关键字或保留字
	  4.采用驼峰命名法
6.JS 中6种数据类型：
	String 	字符串    用""或者''不能混用   
			   \转移字符 \" 表示"   \'表示'  \n表示换行  \t表示制表符（相当于TAB键）  \\表示\		   		
	Number  数值      包括整数和浮点数（小数）
			  最大值Number.MAX_VALUE=1.7976931348623157e+308  超过最大值Infinity正无穷 -Infinity负无穷
			  最小是Number.MIN_VALUE=5e-324 无限接近0的最小数
			  NaN 是一个特殊的数值，表示Not A Number 
	Boolean 布尔值    只有2个  true 表示真  false表示假
	Null    空值      只有1个值就是null 专门用来表示空对象 用typeof检测类型反馈Object 
	Undefined 未定义  只有1个值就是undefined 用typeof检测返回undefined 定义过但是未赋值
	以上为基本数据类型

	下面为引用数据类型
	Object  对象
	Array: 特别的对象类型(下标/内部数据有序)
	Function: 特别的对象类型(可执行)

	- 判断
		typeof:
			可以区别: 数值, 字符串, 布尔值, undefined, function
			不能区别: null与对象, 一般对象与数组
		instanceof:
			专门用来判断对象数据的类型: Object, Array与Function
			- instanceof是如何判断的?
				* 表达式: A instanceof B
				* 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false
				* Function是通过new自己产生的实例
		===
			可以判断: undefined和null

	- undefined与null的区别?
		undefined代表没有赋值
		null代表赋值了, 只是值为null
	- 什么时候给变量赋值为null呢?
		var a = null //a将指向一个对象, 但对象此时还没有确定
		a = null //让a指向的对象成为垃圾对象

	
7.检查变量类型 语法： typeof 变量 列如：console.log(typeof a);
8.强制数据类型转换  
		1.将其他数据类型转换为String
		方法一：调用被转换数值类型的toString()方法 注：unll 和 undefined 这2个值没有toString方法
		方法二：调用String()函数 对于Number和Boolena其实就是调用toString()方法 对于null和undefined不会调用toString()方法 而是直接转换
		2.将其他数据类型装换为Number
		方法一：调用Number()函数 字符串--> 数字 1.纯数字字符串，直接转换为数字 2.含有非数字内容，转换为NaN 3.字符串是空串或者全是空格的字符串，转换为0
					 布尔-->数字 true 转换为1  false 转换为0
					 null-->数字  为0	
					 undefined-->数字 为NaN
		方法二：专门用来对付字符串
			parseInt() 把一个字符串转换为整数
			parseFloat() 把一个字符串转换为浮点数
			注:如果对非String使用以上 会先将其转换为String 然后在操作
		3.将其他数据类型转换为Boolean
			使用Boolean()函数 数字-->布尔 除了0和NaN其余全为true
					  字符串-->布尔 除了空串其余全为true
					  null和undefined转换为布尔为flase
					  对象转换为布尔为true 
9.其他的进制数字   在JS中，用0x开头表示16进制数字，如：0x10 输出为10进制16
			   用0开头表示8进制数字，如070 输出10进制56
		           用0b开头表示2进制数字（不是所有浏览器都支持），如0b10 输出10进制2
		   a=parseInt(a,10) 可以在parseInt（）中传递一个第二个参数，来指定数字的进制
10.运算符	typeof是一个运算符，可以获得一个值的类型，并将结果以字符串的形式返回
		算数运算符  除了加法 当对非Number类型的值进行运算时，会将值转换为Number然后在运算  注：任何值和NaN运算都得NaN
			+ 如果2个字符串进行加法运算，则会进行拼串，任何值和字符串相加，都会先转换为字符串，然后在拼串  可以给任意数据类型+""即可转换为String
			- 减法 *乘法 /除法  可以通过一个值-0 *1 /1来转换Number
			% 取模运算（取余数）
11.一元运算符 + 正号 不会对数字产生任何影响
	      - 负号 负号可以对数字进行负号取反
	      对于非Number的数据类型 会先转换成Number在运算。 对其他数据类型使用+将其装换为number
	      typeof 变量
12.自增和自减（课程17）  a++和++a 对于一个变量自增以后，原变量的值会立即自增1 但是a++的值为原变量的值（自增前的值） ++a的值为原变量的新值（自增后的值） 
13.逻辑运算符   !
			- 非运算可以对一个布尔值进行取反，true变false false边true
			- 当对非布尔值使用!时，会先将其转换为布尔值然后再取反
			- 我们可以利用!来将其他的数据类型转换为布尔值
		
		&&
			- &&可以对符号两侧的值进行与运算
			- 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。
			- 与是一个短路的与，如果第一个值是false，则不再检查第二个值
			- 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值
			- 规则：
					1.如果第一个值为false，则返回第一个值
					2.如果第一个值为true，则返回第二个值
		
		||
			- ||可以对符号两侧的值进行或运算
			- 只有两端都是false时，才会返回false。只要有一个true，就会返回true。
			- 或是一个短路的或，如果第一个值是true，则不再检查第二个值
			- 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值
			- 规则：	
					1.如果第一个值为true，则返回第一个值
					2.如果第一个值为false，则返回第二个值
14.赋值运算符
		= 
			- 可以将符号右侧的值赋值给左侧变量
			
		+=
			- a += 5 相当于 a = a+5
			- var str = "hello";  str += "world";
			
		-=
			- a -= 5  相当于 a = a-5
			
		*=
			- a *= 5 相当于 a = a*5
			
		/=
			- a /= 5 相当于 a = a/5	
	
		%=
			- a %= 5 相当于 a = a%5	
15.关系运算符
		- 关系运算符用来比较两个值之间的大小关系的
			>
			>=
			<
			<=
		- 关系运算符的规则和数学中一致，用来比较两个值之间的关系，
			如果关系成立则返回true，关系不成立则返回false。
		- 如果比较的两个值是非数值，会将其转换为Number然后再比较。
		- 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。  
16.utf-8编码如何使用   在script中 <script> \u四位编码(16进制)   </script>    在页面中<body> &#编码（10进制，需要转换用计算器）; </body>
17.相等运算符	==
			- 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false
			- 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，
				转换后相等它也会返回true
		!=
			- 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false
			- 不等也会做自动的类型转换。
			
		===
			- 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，
				如果两个值的类型不同，则直接返回false
				
		!==
			- 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true
			
		特殊的值：
			- null和undefined
				- 由于undefined衍生自null，所以null == undefined 会返回true。
					但是 null === undefined 会返回false。
					
			- NaN
				- NaN不与任何值相等，包括它自身 NaN == NaN //false
				
			- 判断一个值是否是NaN
				- 使用isNaN()函数
18.三元运算符：?:
			- 语法：条件表达式?语句1:语句2;
			- 执行流程：
				先对条件表达式求值判断，
					如果判断结果为true，则执行语句1，并返回执行结果
					如果判断结果为false，则执行语句2，并返回执行结果
19.流程控制语句
	- 程序都是自上向下的顺序执行的，
		通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。
	- 分类：
		1.条件判断语句
		2.条件分支语句
		3.循环语句
		
	条件判断语句
		- 条件判断语句也称为if语句
		- 语法一：
			if(条件表达式){
				语句...
			}
			
			- 执行流程：
				if语句执行时，会先对条件表达式进行求值判断，
					如果值为true，则执行if后的语句
					如果值为false，则不执行
		- 语法二：
			if(条件表达式){
				语句...
			}else{
				语句... 
			}
			
			- 执行流程：
				if...else语句执行时，会对条件表达式进行求值判断，
					如果值为true，则执行if后的语句
					如果值为false，则执行else后的语句
			
		- 语法三：
			if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else{
				语句...
			}
			
			- 执行流程
				- if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断，
					如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。
					如果判断结果为false，则继续向下判断，直到找到为true的为止。
					如果所有的条件表达式都是false，则执行else后的语句
20.条件分支语句
	- switch语句
	- 语法:
		switch(条件表达式){
			case 表达式:
				语句...
				break;
			case 表达式:
				语句...
				break;
			case 表达式:
				语句...
				break;
			default:
				语句...
				break;
		}
		
	- 执行流程：
		- switch...case...语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较，
			如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。
			如果所有的case判断结果都为false，则从default处开始执行代码。
21.循环语句
	- 通过循环语句可以反复执行某些语句多次
	- while循环
		- 语法：
			while(条件表达式){
				语句...
			}
			
		- 执行流程：
			while语句在执行时，会先对条件表达式进行求值判断，
				如果判断结果为false，则终止循环
				如果判断结果为true，则执行循环体
				循环体执行完毕，继续对条件表达式进行求值判断，依此类推
				
	- do...while循环
		- 语法:
			do{
				语句...
			}while(条件表达式)
			
		- 执行流程
			do...while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断，
				如果判断判断结果为false，则终止循环。
				如果判断结果为true，则继续执行循环体，依此类推
				
		- 和while的区别：
			while：先判断后执行
			do...while: 先执行后判断
			- do...while可以确保循环体至少执行一次。
			
			
	- for循环
		- 语法：
			for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){
				③语句...
			}
		- 执行流程：
			首先执行①初始化表达式，初始化一个变量，
			然后对②条件表达式进行求值判断，如果为false则终止循环
			如果判断结果为true，则执行③循环体
			循环体执行完毕，执行④更新表达式，对变量进行更新。
			更新表达式执行完毕重复②
			
	- 死循环
		while(true){
		
		}
		
		for(;;){
		
		}
提升性能:
	break 可以退出switch语句或循环语句,不能在if语句中使用break和continue,终止距离最近的循环语句
	label:循环语句  然后在break label;可以结束想要的循环
	continue跳过当次循环
	开方Math.sqrt()



22.总结类型转换 1.转换为String a.调用被转换函数类型的tostring（）方法
			       b.string()函数
			       c.+""加空串	       
		2.转换为Number a.Number（）函数
			       b.parseInt()  和parseFloat()
			       c.-0 *1 /1
			       d.+    直接前面添加一元运算符
		3.转换为Boolean a.Boolean()函数
				b.! !  
23.开启计时器测量时间 console.time("计时器的名字") 需要一个字符串作参数，用字符串给计时器进行表示 结束用console.timeEnd("")
24.对象（Object）
	- 对象是JS中的引用数据类型
	- 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性
	- 使用typeof检查一个对象时，会返回object
	对象的分类：1.内建对象：由ES标准中定义的对象，在ES实现中都可以使用，如：Math String Number Function.....
		    2.宿主对象：在JS运行环境提供的对象，目前主要讲由浏览器提供的对象.如BOM组 DOM组。
		    3.自定义对象：由开发人员自己创建的对象。
25.     - 创建对象
		- 方式一：
			- var obj = new Object();
		- 方式二：
			- var obj = {};
			
	- 向对象中添加属性
		- 语法：
			对象.属性名 = 属性值;
			对象["属性名"] = 属性值;
			
			- 对象的属性名没有任何要求，不需要遵守标识符的规范，
				但是在开发中，尽量按照标识符的要求去写。
			- 属性值也可以任意的数据类型。

	- 读取对象中的属性
		- 语法：
			对象.属性名
			对象["属性名"]
		- 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined
		
	- 删除对象中的属性
		- 语法：
			delete 对象.属性名
			delete 对象["属性名"]
	- 使用in检查对象中是否含有指定属性
		- 语法："属性名" in 对象
			- 如果在对象中含有该属性，则返回true
				如果没有则返回false
	- 使用对象字面量，在创建对象时直接向对象中添加属性
		语法：
			var obj = {
							属性名:属性值,
							属性名:属性值,
							属性名:属性值,
							属性名:属性值
					}
					
	- 基本数据类型和引用数据类型
		- 基本数据类型
			String Number Boolean Null Undefined
		- 引用数据类型
			Object
		- 基本数据类型的数据，变量是直接保存的它的值。
			变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。
		- 引用数据类型的数据，变量是保存的对象的引用（内存地址）。
			如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。
		- 比较两个变量时，对于基本数据类型，比较的就是值，
			对于引用数据类型比较的是地址，地址相同才相同

26.函数（Function）	
	- 函数也是一个对象，也具有普通对象的功能
	- 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码
	- 使用typeof检查一个函数时会返回function
	- 创建函数
		- 函数声明
			function 函数名([形参1,形参2...形参N]){
				语句...
			}
		
		- 函数表达式
			var 函数名 = function([形参1,形参2...形参N]){
				语句...
			};
			
	- 调用函数
		- 语法：函数对象([实参1,实参2...实参N]);
			fun() sum() alert() Number() parseInt()
		- 当我们调用函数时，函数中封装的代码会按照编写的顺序执行
		
		- call()
		- apply()
		- 这两个方法都是函数对象的方法需要通过函数对象来调用
		- 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this
		- 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递

	- 形参和实参
		- 形参：形式参数
			- 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开
				定义形参就相当于在函数内声明了对应的变量但是并不赋值，
				形参会在调用时才赋值。
				
		- 实参：实际参数
			- 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,
				调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。
				如果实参的数量大于形参，多余实参将不会赋值，
				如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined
	
	- arguments
		- arguments和this类似，都是函数中的隐含的参数
		- arguments是一个类数组元素，它用来封装函数执行过程中的实参
			所以即使不定义形参，也可以通过arguments来使用实参
		- arguments中有一个属性callee表示当前执行的函数对象
	
27.
	- 返回值，就是函数执行的结果。
		- 使用return 来设置函数的返回值。
		- 语法：return 值;
			- 该值就会成为函数的返回值，可以通过一个变量来接收返回值
		- return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。
		- return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。
		- 如果return后不跟值，或者是不写return则函数默认返回undefined。
		- break、continue和return
			- break
				- 退出循环
			- continue
				- 跳过当次循环
			- return
				- 退出函数
				
	- 参数，函数的实参也可以是任意的数据类型（对象，函数）。

	- 方法（method）
		- 可以将一个函数设置为一个对象的属性，
			当一个对象的属性是一个函数时，
				我们称这个函数是该对象的方法。
		- 对象.方法名();
		- 函数名();
28.枚举对象中的属性 使用for ... in 语句  对象中有几个属性，循环体就会执行几次 每次执行时，会将对象中的一个属性的名字赋值给变量
	列如：for（var n in obj）{
		 console.log(n);		   obj是对象
	      }
29.作用域
	- 作用域简单来说就是一个变量的作用范围。
	- 在JS中作用域分成两种：
		1.全局作用域
			- 直接在script标签中编写的代码都运行在全局作用域中
			- 全局作用域在打开页面时创建，在页面关闭时销毁。
			- 全局作用域中有一个全局对象window，window对象由浏览器提供，
				可以在页面中直接使用，它代表的是整个的浏览器的窗口。
			- 在全局作用域中创建的变量都会作为window对象的属性保存
				在全局作用域中创建的函数都会作为window对象的方法保存
			- 在全局作用域中创建的变量和函数可以在页面的任意位置访问。
				在函数作用域中也可以访问到全局作用域的变量。
			- 尽量不要在全局中创建变量	
		2.函数作用域
			- 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。
			- 函数作用域在函数执行时创建，在函数执行结束时销毁。
			- 在函数作用域中创建的变量，不能在全局中访问。
			- 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，
				如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，
					如果找到了则使用，找不到则继续向上找，一直会
					
		- 变量的声明提前
			- 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。
				所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。
			- 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，
				如果没有使用var关键字声明变量，则变量会变成全局变量
				
		- 函数的声明提前
			- 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，
				也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性
			- 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。
30.  this（上下文对象）	
	- 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。
		使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。
	- this的不同的情况：
		1.以函数的形式调用时，this是window
		2.以方法的形式调用时，this就是调用方法的对象
		3.以构造函数的形式调用时，this就是新创建的对象
		4.使用call和apply调用时，this是指定的那个对象
		5.在全局作用域中this代表window
31.使用工厂的方法创建对象 详细请看课程63
32.构造函数
	- 构造函数是专门用来创建对象的函数
	- 一个构造函数我们也可以称为一个类
	- 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例
	- 通过同一个构造函数创建的对象，我们称为一类对象
	- 构造函数就是一个普通的函数，只是他的调用方式不同，
		如果直接调用，它就是一个普通函数
		如果使用new来调用，则它就是一个构造函数
		
	- 例子：
		function Person(){
		
		}
		
	- 构造函数的执行流程：
		1.创建一个新的对象
		2.将新的对象作为函数的上下文对象（this）
		3.执行函数中的代码
		4.将新建的对象返回
		
	- instanceof 用来检查一个对象是否是一个类的实例
		- 语法：对象 instanceof 构造函数
			- 如果该对象时构造函数的实例，则返回true，否则返回false
			- Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true
			
	- 枚举对象中的属性
		for...in
		语法：
			for(var 属性名 in 对象){
			
			}
			
		for...in语句的循环体会执行多次，对象中有几个属性就会执行几次，
			每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性
33.原型（prototype）
	- 创建一个函数以后，解析器都会默认在函数中添加一个数prototype
		prototype属性指向的是一个对象，这个对象我们称为原型对象。
	- 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。
		这个隐含的属性可以通过  对象.__proto__  来访问。

	- 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。
		我们可以将对象中共有的属性和方法统一添加到原型对象中，
			这样我们只需要添加一次，就可以使所有的对象都可以使用。
	- 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，
		如果在自身中找到了，则直接使用。
		如果没有找到，则去原型对象中寻找，如果找到了则使用，
		如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null，
		如果依然没有找到则返回undefined
	- hasOwnProperty()
		- 这个方法可以用来检查对象自身中是否含有某个属性(私有属性检测)
		- 语法：对象.hasOwnProperty("属性名")
34.垃圾回收  将不在使用的对象设置为null  obj=null;
35.数组（Array）
	- 数组也是一个对象，是一个用来存储数据的对象
		和Object类似，但是它的存储效率比普通对象要高
	- 数组中保存的内容我们称为元素	
	- 数组使用索引（index）来操作元素
	- 索引指由0开始的整数
	-检查一个对象是不是数组 Array.isArray();  ()中填写要检查的对象
	- 数组的操作：
		- 创建数组
			- var arr = new Array();
			- var arr = [];
			
		- 向数组中添加元素
			- 语法；
				数组对象[索引] = 值;
				arr[0] = 123;
				arr[1] = "hello";
				
		- 创建数组时直接添加元素
			- 语法：
				var arr = [元素1,元素2....元素N];
				- 例子：
					var arr = [123,"hello",true,null];
					
		- 获取和修改数组的长度
			- 使用length属性来操作数组的长度
			- 获取长度：
				数组.length
				- length获取到的是数组的最大索引+1
				- 对于连续的数组，length获取到的就是数组中元素的个数
			- 修改数组的长度
				数组.length = 新长度
					- 如果修改后的length大于原长度，则多出的部分会空出来
					- 如果修改后的length小于原长度，则原数组中多出的元素会被删除
			- 向数组的最后添加元素
				数组[数组.length] = 值; 
		- 数组的方法
		- push()
			- 用来向数组的末尾添加一个或多个元素，并返回数组新的长度
			- 语法：数组.push(元素1,元素2,元素N)
		- pop()
			- 用来删除数组的最后一个元素，并返回被删除的元素
		- unshift()
			- 向数组的前边添加一个或多个元素，并返回数组的新的长度
		- shift()
			- 删除数组的前边的一个元素，并返回被删除的元素
		- slice()
			- 可以从一个数组中截取指定的元素
			- 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回
			- 参数：
				1.截取开始位置的索引（包括开始位置）
				2.截取结束位置的索引（不包括结束位置）
					- 第二个参数可以省略不写，如果不写则一直截取到最后
				- 参数可以传递一个负值，如果是负值，则从后往前数
		- splice()
			- 可以用来删除数组中指定元素，并使用新的元素替换
				该方法会将删除的元素封装到新数组中返回
			- 参数：
				1.删除开始位置的索引
				2.删除的个数
				3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边
		- reverse()
		- 可以用来反转一个数组，它会对原数组产生影响
		- concat()
			* 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回
			* 语法 array1.concat(array2,array3,...,arrayX)
		- join()
		- 可以将一个数组转换为一个字符串
		- 参数：
			需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素
			如果不指定连接符则默认使用,
		- sort()
		- 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序
			调用以后，会直接修改原数组。
		- 可以自己指定排序的规则，需要一个回调函数作为参数：
			function(a,b){
				
				//升序排列
				//return a-b;
				//中文名字按字母表排序 "郭军驾".localeCompare("蒋张涛")   -1
							"guojunjia".localeCompare("jiangzhangtao")
				return a.name.localeCompare(b.name)
				//降序排列
				return b-a;
			}
		- map() 方法  IE9以下不支持
			* map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
			* map() 方法按照原始数组元素顺序依次处理元素。
			* map() 不会对空数组进行检测。
			* map() 不会改变原始数组。
			* 语法  array.map(function(currentValue,index,arr), thisValue)
				* function(currentValue,index,arr) 必须。函数，数组中的每个元素都会执行这个函数
					* currentValue 必须。当前元素的值
					* index 可选。当期元素的索引值
					* arr 可选。当期元素属于的数组对象
				* thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined"
		- filter() 方法 过滤数组中的元素  IE9以下不支持
			* filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
			* filter() 不会对空数组进行检测。
			* filter() 不会改变原始数组。
			* 语法  array.filter(function(currentValue,index,arr), thisValue)
				* function(currentValue,index,arr) 必须。函数，数组中的每个元素都会执行这个函数
					* currentValue 必须。当前元素的值
					* index 可选。当期元素的索引值
					* arr 可选。当期元素属于的数组对象
				* thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined"
		- indexOf() 方法 Internet Explorer 8 及 更早IE版本不支持该方法。
			* indexOf() 方法可返回某个指定的字符串值在数组中首次出现的索引。
			* 如果在数组中没找到字符串则返回 -1。
			* 如果你想查找字符串最后出现的位置，请使用 lastIndexOf() 方法。
			* 语法  array.indexOf(item,start)
				* item 必须。查找的元素。
				* start 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length -   如省略该参数，则将从字符串的首字符开始检索。
			* 返回值 Number  元素在数组中的位置,如果没与搜索到则返回 -1

	

		- 遍历数组
		- 遍历数组就是将数组中元素都获取到
		- 一般情况我们都是使用for循环来遍历数组：
			for(var i=0 ; i<数组.length ; i++){
				//数组[i]
			}
			
		- 使用forEach()方法来遍历数组（不兼容IE8）
		
			数组.forEach(function(value , index , obj){
			
			},thisValue);
			
			forEach()方法需要一个回调函数作为参数，
				数组中有几个元素，回调函数就会被调用几次，
				每次调用时，都会将遍历到的信息以实参的形式传递进来，
				我们可以定义形参来获取这些信息。
				value:正在遍历的元素
				index:正在遍历元素的索引
				obj:被遍历对象
				thisValue:可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined"
		- 写一个forEach工具方法来兼容ie8
			var util = {
				each:(function(){
					if([].forEach){ //如果forEach存在
						return function(list,fn,context){
							list.forEach(fn,context);
						}
					}else{
						return function(list,fn,context){
							for(var i=0;i<list.length;i++){
								fn.call(context,list[i],i,list);
							}
						}	
					}
				})()

			}
			使用
			var arr = [1,2,3];
			util.each(arr,function(item,index,all){
				console.log(this.name,item,index,all);
			},{name:'zfpx'});

36.Date
	- 日期的对象，在JS中通过Date对象来表示一个时间
	- 创建对象
		- 创建一个当前的时间对象
			var d = new Date();
		- 创建一个指定的时间对象
			var d = new Date("月/日/年 时:分:秒");
			
	- 方法：
		getDate()
			- 当前日期对象是几日（1-31）
			
		getDay() 
			- 返回当前日期对象时周几（0-6）
				- 0 周日
				- 1 周一 。。。
				
		getMonth()
			- 返回当前日期对象的月份（0-11）
			- 0 一月 1 二月 。。。
		getFullYear() 从 Date 对象以四位数字返回年份。 
		
		getHours() 返回 Date 对象的小时 (0 ~ 23)。 
		getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 
		getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 
		getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 
		
		getTime()
			- 返回当前日期对象的时间戳
			- 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数
				计算机底层保存时间都是以时间戳的形式保存的。
				
		Date.now()
			- 可以获取当前代码执行时的时间戳
37.Math			
	- Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法
		我们可以直接使用它来进行数学运算相关的操作
	- 方法：
		Math.PI
			- 常量，圆周率
		Math.abs()
			- 绝对值运算
		Math.ceil()
			- 向上取整
		Math.floor()
			- 向下取整
		Math.round()
			- 四舍五入取整
		Math.random()	
			- 生成一个0-1之间的随机数
			- 生成一个x-y之间的随机数
				Math.round(Math.random()*(y-x)+x);
		Math.pow(x,y)
			- 求x的y次幂
		Math.sqrt()
			- 对一个数进行开方
		Math.max()
			- 求多个数中最大值
		Math.min()
			- 求多个数中的最小值
38.包装类		
	- 在JS中为我们提供了三个包装类：
		String() Boolean() Number()
		- 通过这三个包装类可以创建基本数据类型的对象
		例子：
			var num = new Number(2);
			var str = new String("hello");
			var bool = new Boolean(true);
		- 但是在实际应用中千万不要这么干。
	
	- 当我们去操作一个基本数据类型的属性和方法时，
		解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，
		操作完成以后再将这个临时对象进行销毁。
39.字符串的相关的方法
	length
		- 获取字符串的长度
	charAt()
		- 根据索引获取指定的字符
	charCodeAt()
		- 根据索引获取指定的字符编码
	String.fromCharCode()
		- 根据字符编码获取字符
	indexOf()
	lastIndexOf()
		- 从一个字符串中检索指定内容
		- 需要一个字符串作为参数，这个字符串就是要检索的内容，
			如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。
		- 可以指定一个第二个参数，来表示开始查找的位置
		- indexOf()是从前向后找
		- lastIndexOf()是从后向前找
	slice()
		- 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量
		- 参数：
			第一个：截取开始的位置（包括开始）
			第二个：截取结束的位置（不包括结束）
				- 可以省略第二个参数，如果省略则一直截取到最后
			- 可以传负数，如果是负数则从后往前数
	substr()	
		- 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量
		
	substring()
		- 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，
			substring()中如果第二个参数小于第一个，自动调整位置
	toLowerCase() 
		- 将字符串转换为小写并返回
	toUpperCase() 
		- 将字符串转换为大写并返回
	split()
		- 可以根据指定内容将一个字符串拆分为一个数组
		- 参数：
			- 需要一个字符串作为参数，将会根据字符串去拆分数组
				可以接收一个正则表达式，此时会根据正则表达式去拆分数组
				
	match() 
		- 可以将字符串中和正则表达式匹配的内容提取出来
		- 正则里面还有match方法的详情
		- 参数：
			- 正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来
					并且封装到一个数组中返回
		- 原理：(不全)
			String.prototype.match = function (reg) {
				//this-->就是我们要操作的那个字符串，原型上的方法，里面的this都是我们要操作的当前实例
				var ary = [];
				var res = reg.exec (this);
				while (res) {
					ary.push (res[0]);
					res = reg.exec (this);
				}
				return ary;
			}
	
	replace()  
		- 可以将字符串中指定内容替换为新的内容
		- 参数：
			- 第一个：被替换的内容，可以是一个正则表达式
				* 如果第1个值是一个字符串，则替换的时候只会替换一次，而且连续使用也是每次从第1个字符串开始替换
			- 第二个：替换的新内容,一般为一个字符串
				- 如果把第2个参数换成一个匿名函数
					var str = "zhufeng2015zhufeng2016";
					var reg = /\d+/g;
					str.replace(reg , function (){
						console.log (arguments);
						return 1;
					})
					* 匿名函数执行多少次，取决于大正则能在字符串中捕获多少次
					* 每次执行匿名函数，里面传递的参数值arguments和我们自己通过exec捕获到的结果是非常类似的(即使正则有分组，同样可以通过arguments捕获到)
					* return : 返回的结果是啥，就相当于把当前这一次大正则捕获的内容替换成返回的内容
			
		
			
	search() 
		- 可以根据正则表达式去字符串中查找指定的内容
		- 参数：
			正则表达式，将会根据该表达式查询内容，
					并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1。
40.正则表达式 RegExp
	- 正则用来定义一些字符串的规则。
		- 作用：
		1.匹配：程序可以根据这些规则来判断一个字符串是否符合规则 reg.test(str)
		2.捕获：也可以将一个字符串中符合规则的内容提取出来。 reg.exec(str)
	- 创建正则表达式
		- var reg = new RegExp("正则","匹配模式");
		- var reg = /正则表达式/匹配模式
		关于字面量方式和实例创建的方式在正则中的区别？
		1.字面量方式中出现的一切都是元字符，所以不能进行变量值的拼接，而实例创建的方式是可以的
		2.字面量方式中直接写\d就可以，而实例中需要把它转义 \\d

	- 语法：
		匹配模式：
			i(ignoreCase):忽略大小写
			g(global):全局匹配模式,查找所有匹配而非在找到第1个匹配后停止，原理：每一次捕获结束，lastIndex的值都变为了最新的值，下一次捕获从最新的位置开始查找
			m(multiline):多行匹配
			- 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求
	
			
		正则语法		
			| 或
			[] 或   不识别两位数[12-68]表示 1、2-6中的一个、8 三个中的一个
			[^ ] 除了
			[a-z] 小写字母
			[A-Z] 大写字母
			[A-z] 任意字母
			[0-9] 任意数字
		- 量词
			{n} 正好n次
			{m,n} m-n次
			{m,} 至少m次
			+	至少1次 {1,}
			?   0次或1次 {0,1}
				- ？在正则中很多作用
					* ?量词 ：放在一个普通的元字符后面代表出现0-1次 有效数字的正则:var reg = /^[+-]?\d+(\.\d+)?$/;
					* 取消贪婪性：放在一个量词的元字符后面是取消捕获时候的贪婪性
					* (?:)匹配不捕获 ：的意思是只匹配不捕获var reg = /^[+-]?\d+(?:\.\d+)?$/;
					* (?=exp)表示给前面一个小正则添加条件。例子/(\d)(?!$)/g 表示匹配到的一个数字，条件为：不是结尾处的数字 ;/(\d)(?=$)/g 表示只捕获条件为结尾处的一个数字
			*   0次或多次 {0,}
		- 正向预查和负向预查
			* (?=exp) Zero-width positive lookahead (本身不占宽度只是修饰前面()小正则的条件,肯定的，向前看修饰前面条件的意思)  例子：/\d(?=(\d{3})+$)/ 表示匹配的到的数字，该数字的条件为：该数字后面的数字个数为3的倍数，且必须找到最末尾
			* (?!exp) Zero-width negative lookahead 例子：(?!$)在小正则后面加这个,表示匹配到的不能是结尾处的
			* (?<=exp) JS好像不支持
			* (?<!exp) JS好像不支持
	- 元字符：
		* 每一个正则表达式都是由元字符和修饰符组成的
		* 元字符就是在/ /之间具有意义的一些字符
		- 转义字符
			\ 在正则表达式中使用\作为转义字符
			\. 表示.
			\\ 表示\
			. 表示任意字符
			\w	  字母 数字 _
				- 相当于[A-z0-9_]
			\W	  除了字母 数字 _
				- 相当于[^A-z0-9_]
			\d        任意数字
				- 相当于[0-9]
			\D	  除了数字
				- 相当于[^0-9]
			\s
				- 空格、制表符、换页符
			\S
				- 除了空格
			\b
				- 单词边界
			\B
				- 除了单词边界
		^ 表示开始
		$ 表示结束
		() 分组的作用：
			1. 改变x|y的默认的优先级
			2. 分组引用
				例子：var reg = /^(\w)\1(\w)\2$/ ;
				      var reg = /^(\w)(\w)\w\2\1$/;  符合要求的123321 abcba 
				* \1表示和第1个分组出现一模一样的内容(和对应分组中的内容的值要完全一样)；\2表示和第2个分组出现一模一样的内容
				* 引用：去除重复
					var str = "aaaaabbbbcccc6555555448888"
					str = str.replace(/(\w)\1+/g,"$1");
			3. 分组捕获
				* 正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到
				* (?:)在分组中?:的意思是只匹配不捕获
				var reg = /^(\d{2})(\d{4})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(?:\d|X)$/;
				var str = "420528199406270717";
				console.log(reg.exec(str));
				//["420528199406270717","42","0528","1994","06","27","07","1",index:0,input:"420528199406270717"]
				结果：  第1项为大正则匹配的内容
					第2项为第一个分组的内容
					...
				console.log(str.match(reg)); //这里match的结果和上面一样,主要大正则只一次全部捕获到了
	- 方法：
		- 正则的捕获reg.exec(str)
			* 每一次捕获的时候都是先进行默认的匹配，如果没有匹配成功的，捕获的结果是null，只有有匹配的内容我们才能捕获到；
			* 捕获的内容格式：
				1)捕获的内容是一个数组
					* 数组中的第一项是当前大正则捕获的内容
					* index:捕获内容在字符串中开始的索引位置
					* input:捕获的原始字符串
				2)正则捕获的特点
					* 懒惰性：每次执行exec只捕获第1个匹配的内容，在不进行任何处理的情况下，只会捕获第1个匹配的内容，解决：后面加g
						- 写一个循环来获取捕获到一个字符串中的所有匹配的内容，放到一个数组中的方法
							var reg = /\d+/g;
							var str = "zhufeng2015wang1020haha50630";
							var ary = [];
							var res = reg.exec(str);//先捕获一次
							while (res){
								ary.push(res[0]);  //这里一定要用res[0]，取出数值中的第1项，后面的要么是小正则的捕获到的，要么是index和input不需要
								res = reg.exec(str);
							}

					* lastIndex:是正则每一次捕获在字符串中开始查找的位置，默认是0
					* 贪婪性：正则的每一次捕获都是按照匹配最长的结果捕获的，解决：在量词元字符后面添加一个?
		- 字符串中的match方法
			* 可以把所有和正则匹配的字符都获取到，并且封装到一个数组中返回
				var reg = /\d+/g;
				var str = "zhufeng2015wang1020haha50630"; 
				var ary = str.match(reg);
				console.log(ary);
			* 虽然match方法更加简洁一些，但是在分组捕获的情况下，match只能捕获到大正则匹配的内容，而对于小正则捕获的内容则无法获取到。
				例如:
					var reg = /zhufeng(\d+)/g;
					var str = "zhufeng2015zhufeng2016zhufeng2017";
					console.log(reg.exec(str));  //["zhufeng2015","2015",...]
					console.log(reg.exec(str));  //["zhufeng2016","2016",...]
					console.log(reg.exec(str));  //["zhufeng2017","2017",...]
					console.log(str.match(reg)); //["zhufeng2015","zhufeng2016","zhufeng2017",...]
					这里就有区别了match只捕获了大正则匹配的内容,并没有捕获小正则匹配的内容。
		- replace() 字符串的方法也可以进行捕获,并且能替换捕获的内容,详细请参考上面字符串方法
		test()	
			- 可以用来检查一个字符串是否符合正则表达式
			- 如果符合返回true，否则返回false
			- 用法var phoneReg=/^1[3-9][0-9]{9}$/ ; phoneReg.test("字符串")
		-常用正则: 1.中国标准真实姓名 2-4位汉字	var reg = /^[\u4e00-\u9fa5]{2,4}$/ ;
			   2.非空验证 var reg = !/^\s*$/.test(str);
			   3.有效数字 var reg = /^[+-]?\d+(\.\d+)?$/;
			   4.去首尾空格 var reg = /^ +| +$/g
			   5.加千分符的写法:reg = /(\d)(?=(\d{3})+$)/g; str = str.replace (reg,"$1,");

		-练习相关：1.例如：手机号正则表达式 var phoneReg=/^1[3-9][0-9]{9}$/
			   2.去除开头和结尾的全部空格 str.replace(/^\s*|\s*$/g,"");
			   3.邮件格式  var emailReg=/^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/;
41.DOM
	- Document Object Model
	- 文档对象模型，通过DOM可以来任意来修改网页中各个内容
	- 文档
		- 文档指的是网页，一个网页就是一个文档
	- 对象
		- 对象指将网页中的每一个节点都转换为对象
			转换完对象以后，就可以以一种纯面向对象的形式来操作网页了
	- 模型
		- 模型用来表示节点和节点之间的关系，方便操作页面
	- 节点（Node）
		- 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点
		- 虽然都是节点，但是节点的类型却是不同的
		- 常用的节点
			- 文档节点 （Document），代表整个网页
			- 元素节点（Element），代表网页中的标签
			- 属性节点（Attribute），代表标签中的属性
			- 文本节点（Text），代表网页中的文本内容
			
	- DOM操作
		- DOM查询
		- 在网页中浏览器已经为我们提供了document对象，
			它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。
		- document查询方法：
			- 根据元素的id属性查询一个元素节点对象：
				- document.getElementById("id属性值");
			- 根据元素的name属性值查询一组元素节点对象:
				- document.getElementsByName("name属性值");
					* 在IE浏览器中只对表单元素的name起作用
			- 根据标签名来查询一组元素节点对象：
				- document.getElementsByTagName("标签名");
				
		- 元素的属性：
			- 读取元素的属性：
				语法：元素.属性名
				例子：ele.name  
					  ele.id  
					  ele.value 
					  ele.className
					  
			- 修改元素的属性：
				语法：元素.属性名 = 属性值
				
			- innerHTML
				- 使用该属性可以获取或设置元素内部的HTML代码
				
				
	- 事件（Event）
		- 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。
		- 我们可以为事件来绑定回调函数来响应事件。
		- 绑定事件的方式：
			1.可以在标签的事件属性中设置相应的JS代码
				例子：
					<button onclick="js代码。。。">按钮</button>
			2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件
				例子：
					<button id="btn">按钮</button>
					<script>
						var btn = document.getElementById("btn");
						btn.onclick = function(){
						
						};
					</script>
					
	- 文档的加载
		- 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。
		- 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，
			此时将会无法正常获取到DOM对象，导致DOM操作失败。
		- 解决方式一：
			- 可以将js代码编写到body的下边
			<body>
				<button id="btn">按钮</button>
				<script>
					var btn = document.getElementById("btn");
					btn.onclick = function(){
					
					};
				</script>
			</body>
			
		- 解决方式二：
			- 将js代码编写到window.onload = function(){}中
			- window.onload 对应的回调函数会在整个页面加载完毕以后才执行，
				所以可以确保代码执行时，DOM对象已经加载完毕了
			<script>
				window.onload = function(){
					var btn = document.getElementById("btn");
					btn.onclick = function(){
					
					};
				};
			
			</script>	
42.DOM查询
	- 通过具体的元素节点来查询
		- 元素.getElementsByTagName()
			- 通过标签名查询当前元素的指定后代元素
			
		- 元素.childNodes
			- 获取当前元素的所有子节点
			- 会获取到空白的文本子节点
		
		- 元素.children
			- 获取当前元素的所有子元素
		
		- 元素.firstChild
			- 获取当前元素的第一个子节点
		
		- 元素.lastChild
			- 获取当前元素的最后一个子节点
		
		- 元素.parentNode
			- 获取当前元素的父元素
		
		- 元素.previousSibling
			- 获取当前元素的前一个兄弟节点
		
		- 元素.nextSibling
			- 获取当前元素的后一个兄弟节点
	- document对象的其他的属性和方法
		document.all
			- 获取页面中的所有元素，相当于document.getElementsByTagName("*");
			
		document.documentElement
			- 获取页面中html根元素
			
		document.body
			- 获取页面中的body元素
			
		document.getElementsByClassName("")
			- 根据元素的class属性值查询一组元素节点对象
			- 这个方法不支持IE8及以下的浏览器
			
		document.querySelector("")
			- 根据CSS选择器去页面中查询一个元素
			- 如果匹配到的元素有多个，则它会返回查询到的第一个元素	
			
		document.querySelectorAll("")	例如 var div=document.querySelectorAll(".box1 div")
			- 根据CSS选择器去页面中查询一组元素
			- 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个
			
	innerHTML和innerText
		- outerHTML包括自身的div标签也提取出来
		- innerHTML可以识别文本内的标签，把标签也获取到，innerText只获取文字
		- 这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性
		- 两个属性作用类似，都可以获取到标签内部的内容，
			不同是innerHTML会获取到html标签，而innerText会自动去除标签
		- 如果使用这两个属性来设置标签内部的内容时，没有任何区别的	
		
	读取标签内部的文本内容
		<h1>h1中的文本内容</h1>
		元素.firstChild.nodeValue

		DOM修改
	document.createElement()
		- 可以根据标签名创建一个元素节点对象
		
	document.createTextNode()
		- 可以根据文本内容创建一个文本节点对象
		
	父节点.appendChild(子节点)
		- 向父节点中添加指定的子节点
		
	父节点.insertBefore(新节点,旧节点)
		- 将一个新的节点插入到旧节点的前边
		
	父节点.replaceChild(新节点,旧节点)
		- 使用一个新的节点去替换旧节点
		
	父节点.removeChild(子节点)
		- 删除指定的子节点
		- 推荐方式：子节点.parentNode.removeChild(子节点)
43.DOM对CSS的操作
	- 读取和修改内联样式
		- 使用style属性来操作元素的内联样式
		- 读取内联样式：  只能读取内联样式，不能读取style中的样式（当前样式）
			语法：元素.style.样式名
			- 例子：
				元素.style.width
				元素.style.height
				- 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法
					将-去掉，然后-后的字母改大写
				- 比如：background-color --> backgroundColor
						border-width ---> borderWidth
						
		- 修改内联样式：
			语法：元素.style.样式名 = 样式值
			- 通过style修改的样式都是内联样式，由于内联样式的优先级比较高，
				所以我们通过JS来修改的样式，往往会立即生效，
				但是如果样式中设置了!important，则内联样式将不会生效。
				
	- 读取元素的当前样式   课程109课  不仅仅可以读取当前样式
		- 正常浏览器window.getComputedStyle()
			- 使用getComputedStyle()
			- 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式
			- 主要当前元素标签可以在页面中呈现出来，那么它的所有样式都是经过浏览器渲染过的，哪怕有些样式并没有写，也可以获取到
			- 参数：
				1.要获取样式的元素
				2.可以传递一个伪元素，一般传null
			- 例子：
				获取元素的宽度
					getComputedStyle(box , null)["width"];
			- 通过该方法读取到样式都是只读的不能修改

		- IE8
			- 使用currentStyle
			- 语法：
				元素.currentStyle.样式名
			- 例子：
				box.currentStyle["width"]
			- 通过这个属性读取到的样式是只读的不能修改
		-综合自写的查看样式的代码
		function getStyle(obj , name){
				
				if(window.getComputedStyle){
					//正常浏览器的方式，具有getComputedStyle()方法
					return getComputedStyle(obj , null)[name];
				}else{
					//IE8的方式，没有getComputedStyle()方法  注意：IE中如果没有设置属性会返回auto 可以设置属性为0
					return obj.currentStyle[name];
				}
				
				
				
			}




		- 其他的样式相关的属性
		- JS盒子模型属性
		注意：
			* 以下样式都是只读的
			* 以下获取到的值都是整数，浏览器获取结果的时候在原来真实结果上进行了四舍五入
			* 获取浏览器本身页面的可视宽高，以及整个内容宽高,考虑到兼容问题，不管是获取还是设置浏览器页面本身模型，都需要写2套(不同浏览器<html></html>和<body></body>的区别)
				document.documentElement[attr]||document.body[attr];  必须document.documentElement在前
				例如：
				document.documentElement.clientWidth/clientHeight||document.body.clientWidth/clientHeight;
				document.documentElement.scrollWidth/scrollHeight||document.body.scrollWidth/scrollHeight;
		
		clientHeight
			- 元素的可见高度，指元素的内容区和内边距的高度(和内容溢出没有必然联系)
		clientWidth
			- 元素的可见宽度，指元素的内容区和内边距的宽度(和内容溢出没有必然联系)
		clientLeft
			- 左边框的宽度
		clientTop
			- 上边框的宽度
		offsetHeight
			- 整个元素的高度，包括内容区、内边距、边框
		offsetWidth
			- 整个元素的宽度，包括内容区、内边距、边框
		offsetParent
			- 当前元素的定位父元素(当前元素的父级参照物)
			- 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body
			- 在一个平面中，最外层的元素是里面所有元素的父级参照物(和HTML层级结构没有必然的联系)
			- 改变父级参照物需要通过position定位来进行改变:absolute、relative、fixed任意一个值都可以改变父级参照物
		offsetLeft
		offsetTop
			- 当前元素(外边框)和定位父元素(内边框)之间的偏移量
			- offsetLeft水平偏移量  offsetTop垂直偏移量
		
		scrollHeight
		scrollWidth
			- 获取元素滚动区域的高度和宽度
			- scrollHeight:真实内容的高度(包含溢出)+上填充(上内边距)
			- scrollWidth:真实内容的宽度(包含溢出)+左填充(左内边距)
			- 获得的结果都是约等于的值，因为：1.在同一个浏览器中，对溢出内容是否设置overflow = "hidden"对于最终结果有影响;2.在不同的浏览器中获取到的结果也是不相同的；
		scrollTop
		scrollLeft
			- 获取元素垂直和水平滚动条滚动的距离
			- 注意：这2个属性可以获取也可以修改
			- scrollTop存在边界值，我们设置的值比最小值小或者比最大值大都没用，起到的效果依然是边界值的效果
			- 最小值：min = 0  最大值max = scrollHeight - clientHeight;

		判断滚动条是否滚动到底
			- 垂直滚动条
				scrollHeight - scrollTop = clientHeight
				
			- 水平滚动	
				scrollWidth - scrollLeft = clientWidth
44.事件（Event）
	- 事件对象
	- 当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，
		这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。
	- 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存
		- 例子：
			元素.事件 = function(event){
				event = event || window.event;   这个window需要带 因为设置参数为event重复
				
			};
			
			元素.事件 = function(e){
				e = e || event;   就是event没错
				
			};
	- 获取触发事件源: event.target || event.srcElement 火狐event.target ；IE event.srcElement ；chrome2个属性都有
			
	- 事件的冒泡（Bubble）
	- 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。
	- 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消
	- 可以将事件对象的cancelBubble设置为true，即可取消冒泡
		- 例子：
				元素.事件 = function(event){
					event = event || window.event;
					event.cancelBubble = true;
				};
45.事件的绑定
	-使用 对象.事件 = 函数 的形式绑定响应函数，
			它只能同时为一个元素的一个事件绑定一个响应函数，
			不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的
	-addEventListener()
				  	- 通过这个方法也可以为元素绑定响应函数
				  - 参数：
				  		1.事件的字符串，不要on
				  		2.回调函数，当事件触发时该函数会被调用
				  		3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false
				  
				  使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，
				  	这样当事件被触发时，响应函数将会按照函数的绑定顺序执行
				  
				  这个方法不支持IE8及以下的浏览器
				  使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false
					 * 需要使用event来取消默认行为event.preventDefault();
					 * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错
					 */
					event.preventDefault && event.preventDefault();
	attachEvent()
				  	- 在IE8中可以使用attachEvent()来绑定事件
				  - 参数：
				  		1.事件的字符串，要on
				 		2.回调函数
				
				  - 这个方法也可以同时为一个事件绑定多个处理函数，
				  		不同的是它是后绑定先执行，执行顺序和addEventListener()相反
	function bind(obj , eventStr , callback){
				if(obj.addEventListener){
					//大部分浏览器兼容的方式
					obj.addEventListener(eventStr , callback , false);
				}else{
					/*
					 * this是谁由调用方式决定
					 * callback.call(obj)
					 */
					//IE8及以下
					obj.attachEvent("on"+eventStr , function(){
						//在匿名函数中调用回调函数
						callback.call(obj);
					});
				}
			}
- 事件解绑
	事件解除------detachEvent，removeEventListener
	var fun = function(e){
        e.preventDefault();//阻止事件目标的默认动作
        alert(1);
	}
	var btn1= document.getElementById("btn1");
	btn1.addEventListener('click',fun,false);
	btn1.removeEventListener('click',fun,false);





46.事件的捕捉 obj.setCapture &&obj.setCapture(); 给obj开启捕获所有鼠标所按下的事件
47.滚轮事件  onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，
				 	但是火狐不支持该属性
				 
				  在火狐中需要使用 DOMMouseScroll 来绑定滚动事件
				  	注意该事件需要通过addEventListener()函数来绑定
		event.wheelDelta 可以获取鼠标滚轮滚动的方向
				向上滚 120   向下滚 -120
				wheelDelta这个值我们不看大小，只看正负
		
				wheelDelta这个属性火狐中不支持
					在火狐中使用event.detail来获取滚动的方向
					向上滚 -3  向下滚 3
		判断鼠标滚轮滚动的方向
					if(event.wheelDelta > 0 || event.detail < 0){
						
					}else{
						
					}
48.键盘事件   onkeydown
			- 按键被按下
			- 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发
			- 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快
						这种设计是为了防止误操作的发生。
		onkeyup
			- 按键被松开
				
				 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document
		可以通过event.keyCode来获取按键的编码
					  	通过它可以判断哪个按键被按下
					 除了event.keyCode，事件对象中还提供了几个属性
					 	event.altKey
					  	event.ctrlKey
					  	event.shiftKey
					 		- 这个三个用来判断alt ctrl 和 shift是否被按下
					 			如果按下则返回true，否则返回false
49.BOM
			 * 	- 浏览器对象模型
			 * 	- BOM可以使我们通过JS来操作浏览器
			 * 	- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作
			 * 	- BOM对象
			 * 		Window
			 * 			- 代表的是整个浏览器的窗口，同时window也是网页中的全局对象
			 * 		Navigator
			 * 			- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
			 * 		Location
			 * 			- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
			 * 		History
			 * 			- 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
			 * 				由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
			 * 				而且该操作只在当次访问时有效
			 * 		Screen
			 * 			- 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息
			 * 
			 * 
			 * 		这些BOM对象在浏览器中都是作为window对象的属性保存的，
			 * 			可以通过window对象来使用，也可以直接使用
				如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息
			 * 比如：ActiveXObject
			 */
			/*if("ActiveXObject" in window){
				alert("你是IE，我已经抓住你了~~~");
			}else{
				alert("你不是IE~~~");
			}*/
		
	判断浏览器代码  var ua = navigator.userAgent;
			
			console.log(ua);
			
			if(/firefox/i.test(ua)){
				alert("你是火狐！！！");
			}else if(/chrome/i.test(ua)){
				alert("你是Chrome");
			}else if(/msie/i.test(ua)){
				alert("你是IE浏览器~~~");
			}else if("ActiveXObject" in window){
				alert("你是IE11，枪毙了你~~~");
			}
50.History
			 * 	- 对象可以用来操作浏览器向前或向后翻页
		-length
					 * 	- 属性，可以获取到当成访问的链接数量
		-back()
					 * 	- 可以用来回退到上一个页面，作用和浏览器的回退按钮一样
					 */
					//history.back();
		-forward()
					 * 	- 可以跳转下一个页面，作用和浏览器的前进按钮一样
					 */
					//history.forward();
		-go()
					 * 	- 可以用来跳转到指定的页面
					 * 	- 它需要一个整数作为参数
					 * 		1:表示向前跳转一个页面 相当于forward()
					 * 		2:表示向前跳转两个页面
					 * 		-1:表示向后跳转一个页面
					 * 		-2:表示向后跳转两个页面
					 */
					history.go(-2);
51.Location
			 * 	- 该对象中封装了浏览器的地址栏的信息
		-如果直接将location属性修改为一个完整的路径，或相对路径
					 * 	则我们页面会自动跳转到该路径，并且会生成相应的历史记录
					//location = "http://www.baidu.com";
					//location = "01.BOM.html";
					assign()
					 * 	- 用来跳转到其他的页面，作用和直接修改location一样
					//location.assign("http://www.baidu.com");
					reload()
					 * 	- 用于重新加载当前页面，作用和刷新按钮一样
					 * 	- 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面
					//location.reload(true);
					replace()
					 * 	- 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
					 * 		不会生成历史记录，不能使用回退按钮回退
					location.replace("01.BOM.html");
		- 其他跳转页面的方式。
			window.open("http://www.baidu.com") 此方法会直接打开一个新页面，原页面会保留
52.window
		-setInterval()
				 * 	- 定时调用
				 * 	- 可以将一个函数，每隔一段时间执行一次
				 * 	- 参数：
				 * 		1.回调函数，该函数会每隔一段时间被调用一次
				 * 		2.每次调用间隔的时间，单位是毫秒
				 * 
				 * 	- 返回值：
				 * 		返回一个Number类型的数据
				 * 		这个数字用来作为定时器的唯一标识
		-clearInterval()可以用来关闭一个定时器
				//方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
				可以接受任意参数，
				//clearInterval(timer);
		延时调用，
			 * 	延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次
			 * 
			 * 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次
			 * 
			 * 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择
		var timer = setTimeout(function(){
				console.log(num++);
			},3000);	
		//使用clearTimeout()来关闭一个延时调用
			clearTimeout(timer);
53.JSON
			 * 	- JS中的对象只有JS自己认识，其他的语言都不认识
			 * 	- JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，
			 * 		并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互
			 * 	- JSON(window.JSON) 
			 * 		- JavaScript Object Notation JS对象表示法
			 * 		- JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号
			 * 			其他的和JS语法一致
			 * 		JSON分类：
			 * 			1.对象 {}
			 * 			2.数组 []
			 * 
			 * 		JSON中允许的值：
			 * 			1.字符串
			 * 			2.数值
			 * 			3.布尔值
			 * 			4.null
			 * 			5.对象
			 * 			6.数组
		将JSON字符串转换为JS中的对象
			 * 	在JS中，为我们提供了一个工具类，就叫JSON
			 * 	这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON

		var json = '{"name":"孙悟空","age":18,"gender":"男"}';
		var json = '[{"name":"孙悟空","age":18,"gender":"男"},{"name":"猪八戒","age":28,"gender":"男"}]'
			
			/*
			 * json --> js对象
			 * 	 JSON.parse()
			 * 		- 可以将以JSON字符串转换为js对象
			 * 		- 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回
			 */
			
			var o = JSON.parse(json);

		var obj3 = {name:"猪八戒" , age:28 , gender:"男"};
			
			
			/*
			 * JS对象 ---> JSON
			 * 	JSON.stringify()
			 * 		- 可以将一个JS对象转换为JSON字符串
			 * 		- 需要一个js对象/js数组作为参数，会返回一个JSON字符串
			 */
			
			var str = JSON.stringify(obj3);
		 	* JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错，可以引入一个外部js文件来解决
					
		

			







									js高级

一、数据-变量-内存
	1. 什么是数据?
		存储于内存中代表特定信息的'东东', 本质就是0101二进制
		具有可读和可传递的基本特性,万物(一切)皆数据, 函数也是数据
	2. 什么是内存?
		内存的空间是临时的, 而硬盘的空间是持久的
		一块内存包含2个数据:内部存储的数据(一般数据/地址数据);内存地址值数据
	3. 什么是变量?
		值可以变化的量, 由变量名与变量值组成
		一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容
	4. 内存,数据, 变量三者之间的关系
		内存是一个容器, 用来存储程序运行需要操作的数据
		变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据
	5. 在js调用函数时传递变量参数时, 是值传递还是引用传递
		* 只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据
		* 如果后一种看成是引用传递（地址值）, 那就值传递和引用传递都可以有
	6. JS引擎如何管理内存?
		- 内存生命周期
			1). 分配需要的内存
			2). 使用分配到的内存
			3). 不需要时将其释放/归还
		- 释放内存	
			* 为执行函数分配的栈空间内存: 函数执行完自动释放
			* 存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存	

二、关于引用变量赋值问题
	1.2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见
	例子：  var obj1 = {}
		var obj2 = obj1
		obj2.name = 'Tom'
		此时console.log(obj1.name) obj1.name也会输出'Tom'
	2.2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象
	例子 ： var obj3 = {name: 'Tom'}
		var obj4 = obj3
		obj3 = {name: 'JACK'}
		console.log(obj4.name) 此时obj3已经从新赋值对象，obj4.name 应该输出'Tom'
		function f2(obj) {
					obj = {name: 'Bob'}
				}
		f2(obj4);
		console.log(obj4.name) 
		注意：这个很容易错，结果obj4.name还是‘Tom’，这个函数，首先是把obj4的内容传给obj，然后obj又重新赋值了一个对象切断了与obj4之间的联系，并没有修改到原对象。

三、对象
	1. 什么是对象?
		* 代表现实中的某个事物, 是该事物在编程中的抽象
		* 多个数据的集合体(封装体)
		* 用于保存多个数据的容器
	2. 为什么要用对象?
		* 便于对多个数据进行统一管理
	3. 对象的组成
		- 属性
			* 代表现实事物的状态数据
			* 由属性名和属性值组成
			* 属性名都是字符串类型, 属性值是任意类型
		- 方法
			* 代表现实事物的行为数据
			* 是特别的属性==>属性值是函数
	4. 如何访问对象内部数据?
		* .属性名: 编码简单, 但有时不能用
		* ['属性名']: 编码麻烦, 但通用
		问题: 什么时候必须使用['属性名']的方式?
			* 属性名不是合法的标识名。例如:p['content-type'] = 'text/json'
			* 属性名不确定。例如:var prop = 'xxx'; var value = 123 ; p[prop] = value 注意[]没有引号表示变量

四、函数
	1. 什么是函数?
		* 具有特定功能的n条语句的封装体
		* 只有函数是可执行的, 其它类型的数据是不可执行的
		* 函数也是对象
	2. 为什么要用函数?
		* 提高代码复用
		* 便于阅读和交流
	3. 如何定义函数?
		* 函数声明
			function f1 () { // 函数声明
				console.log('f1()')
			}
		* 表达式
			var f2 = function () { // 表达式
				console.log('f2()')
			}
	4. 如何调用(执行)函数?
		* test()
		* new test()
		* obj.test()
		* test.call/apply(obj) 该方法很强大，可以把一个函数成为任意对象的方法进行调用
		举例：
		var obj={};
		function test2(){
			this.xxx="atguigu";
		}
		//obj.test2()不能直接调用，因为根本就没有
		test2.call(obj)      //相当于obj.test2()  可以让一个函数成为指定任意对象的方法进行调用
		console.log(obj.xxx) //验证如果输出atguigu，说明确实调用了
	5. 什么函数才是回调函数?
		* 你定义的
		* 你没有直接调用
		* 但最终它执行了(在特定条件或时刻)
	6. 常见的回调函数?
		* DOM事件函数 ==========>this是触发DOM事件的元素
		* 定时器函数============>this是window
		* ajax回调函数(后面学)
		* 生命周期回调函数(后面学)
	7. IIFE
		全称: Immediately-Invoked Function Expression 立即调用函数表达式
		别名: 匿名函数自调用
		作用:
			* 隐藏内部实现
			* 不污染外部命名空间
			例子：
			(function (i) {
				var a = 4
				function fn() {
					console.log('fn ', i+a)
				}
				fn()
			})(3)
			输出结果为：fn 7
	8.函数中的this
		- this是什么?
			* 一个关键字, 一个内置的引用变量
			* 在函数中都可以直接使用this
			* this代表调用函数的当前对象
			* 在定义函数时, this还没有确定, 只有在执行时才动态确定(绑定)的
		- 如何确定this的值?
			* 本质上任何函数在执行时都是通过某个对象调用的，如果没有指定就是window
			* test()          //this是window
			* obj.test()      //this是obj
			* new test()      //this是新创建的对象
			* test.call(obj)  //this是obj

五、分号问题
	1. js一条语句的后面可以不加分号
	2. 是否加分号是编码风格问题, 没有应该不应该，只有你自己喜欢不喜欢
	3. 在下面2种情况下不加分号会有问题
		* 小括号开头的前一条语句    //不加分号容易被理解为函数执行
		* 中方括号开头的前一条语句  //不加分号容易被理解为数组
	4. 解决办法: 在行首加分号
	5. 强有力的例子: vue.js库

六、原型(prototype)
	1. 函数的prototype属性
		* 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
		function fn() {}
		console.log(fn.prototype, typeof fn.prototype)
		* 原型对象中有一个属性constructor, 它指向函数对象
		console.log(fn.prototype.constructor===fn)  //true
	2. 给原型对象添加属性(一般都是方法)
		* 作用: 函数的所有实例对象自动拥有原型中的属性(方法)
		function F() {}
		F.prototype.setAge = function (age) { // 添加方法
			this.age = age
		}
		var f = new F()    // 创建函数的实例对象
		f.setAge(23)
		console.log(f.age) // 23
	3. 显式原型与隐式原型
		* 每个函数function都有一个prototype，即显式原型
		* 每个实例对象都有一个__proto__，可称为隐式原型
		* 对象的隐式原型的值为其对应构造函数的显式原型的值
			function Fn() {}
			var fn = new Fn()
			console.log(Fn.prototype===fn.__proto__)  //true
		* 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象
		* 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值
		* 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)
	4. 原型链(别名：隐式原型链)
		- 访问一个对象的属性时
			* 先在自身属性中查找，找到返回
			* 如果没有, 再沿着__proto__这条链向上查找, 找到返回
			* 如果最终没找到, 返回undefined
		- 作用: 查找对象的属性(方法)
		- 构造函数/原型/实体对象的关系(图解)
		- 特殊例子：
			a.函数的显式原型指向的对象默认是空Object实例对象（但Object不满足）
			function Fn() {}
			console.log(Fn.prototype instanceof Object)        //true
			console.log(Object.prototype instanceof Object)    //false
			console.log(Function.prototype instanceof Object)  //true
			b.所有函数都是Function的实例（包含Function本身）
			console.log(Function.__proto__ === Function.prototype) //true
			c.Object的原型对象是原型链的尽头
			console.log(Object.prototype.__proto__) //null
	5. 原型链_属性问题
		- 读取对象的属性值时: 会自动到原型链中查找
		- 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值
		- 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上
	6. 给原型链添加方法
		- 方式一
			* 通过Array.prototype.myclice = function () {} 方式添加，只能单个单个添加，而且如果同名可以覆盖浏览器原来的内置方法
			* 代码：Array.prototype.myclice = function () {}
		- 方式二
			* 代码Fn.prototype = {
				   constructor : Fn,
				   a : function (){}
			      }
			* 通过以上代码方法添加，自己从新创建一个原型对象的方式可以覆盖掉浏览器默认创建的，所以要手动给他添加constructor属性，这种方式不能对浏览器内置的原型对象进行添加例如：Math Array
	

七、 变量提升与函数提升
	1. 变量声明提升
		* 通过var定义(声明)的变量, 在定义语句之前就可以访问到
		* 值: undefined
	2. 函数声明提升
		* 通过function声明的函数, 在之前就可以直接调用
		* 值: 函数定义(对象)
	注：先执行变量提升, 再执行函数提升
	3. 预解释
		* 预解释只发生在当前的作用域下，例如：开始只对window下的进行预解释，只有函数执行的时候才会对函数中的进行预解释。
		* 函数在堆空间里面其实是以字符串的形式进行存储的。所以不执行，就是一串字符串。不会进行window下的预解释
		* 如果预解释套在判断里面，不管条件是否成立都要进行预解释
		* 预解释对于同一个变量不会进行重复声明，但是会进行从新定义，也就是函数的地址值赋值

八、 执行上下文
	1. 代码分类(位置)
		* 全局代码
		* 函数代码
	2. 全局执行上下文
		- 在执行全局代码前将window确定为全局执行上下文
		- 对全局数据进行预处理
			* var定义的全局变量==>undefined, 添加为window的属性
			* function声明的全局函数==>赋值(fun), 添加为window的方法
			* this==>赋值(window)
		- 开始执行全局代码
	3. 函数执行上下文
		- 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象
		- 对局部数据进行预处理
			* 形参变量==>赋值(实参)==>添加为执行上下文的属性
			* arguments==>赋值(实参列表), 添加为执行上下文的属性
			* var定义的局部变量==>undefined, 添加为执行上下文的属性
			* function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
			* this==>赋值(调用函数的对象)
		- 开始执行函数体代码
	4. 函数执行上下文栈
		执行过程：
			* 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
			* 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
			* 在函数执行上下文创建后, 将其添加到栈中(压栈)
			* 在当前函数执行完后,将栈顶的对象移除(出栈)
			* 当所有的代码执行完后, 栈中只剩下window
		例子：
			<script type="text/javascript">
				console.log('gb: '+ i)
				var i = 1
				foo(1)
				function foo(i) {
					if (i == 4) {
						return
					}
					console.log('fb:' + i)
					foo(i + 1) //递归调用: 在函数内部调用自己
					console.log('fe:' + i)
				}
				console.log('ge: ' + i)
				</script>
			问题：1. 依次输出什么?
				gb: undefined
				fb: 1
				fb: 2
				fb: 3
				fe: 3
				fe: 2
				fe: 1
				ge: 1
				2. 整个过程中产生了几个执行上下文?  5
				n+1原则，n表示调用几次函数，1表示全局执行上下文
	5.经典面试题
		测试题1: * 先执行变量提升, 再执行函数提升
			function a() {}
			var a
			console.log(typeof a)  // 'function'
		测试题2:

			if (!(b in window)) {
				var b = 1
			}
			console.log(b)		// undefined
		测试题3:
			var c = 1
			function c(c) {
				console.log(c)
				var c = 3
			}
			c(2)			// 报错(因为最后赋值了c=1，所以c不是一个函数无法调用)

九、 作用域
	1. 理解
		* 就是一块"地盘", 一个代码段所在的区域
		* 它是静态的(相对于上下文对象), 在编写代码时就确定了
	2. 分类
		* 全局作用域
		* 函数作用域
		* 没有块作用域(ES6有了)
	3. 作用
		* 隔离变量，不同作用域下同名变量不会有冲突
	4. 作用于与执行上下文
		- 区别1
			* 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
			* 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
			* 函数执行上下文是在调用函数时, 函数体代码执行之前创建
		- 区别2
			* 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
			* 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放
		- 联系
			* 执行上下文(对象)是从属于所在的作用域
			* 全局上下文环境==>全局作用域
			* 函数上下文环境==>对应的函数使用域
	5. 作用域链
		- 理解
			* 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
			* 查找变量时就是沿着作用域链来查找的
			* 作用域的个数遵循n+1原则，n为定义多少个函数，1为全局作用域
		- 查找一个变量的查找规则
			* 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2
			* 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3
			* 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常
	6. 作用域_面试题
		- var x = 10;
		  function fn() {
			console.log(x);
		  }
		  function show(f) {
			var x = 20;
			f();
		  }
		  show(fn);
		输出结果为：10    （因为作用域是静态的，在调用之前就确定好了）
		- var fn = function () {
		  console.log(fn)
		  }
		  fn()
		输出结果为：function(){console.log(fn)}
		- var obj = {
			fn2: function () {
			console.log(fn2)
			//console.log(this.fn2)
			}
		  }
		  obj.fn2()
		输出结果为：报错(因为fn2首先在function下找，如果没有直接去全局找，都没有则报错，下面那种输出就可以找到)
	7. 如何区分私有变量和全局变量？
		* 在全局作用域下声明的变量是全局变量
		* 在“私有作用域中声明的变量”和“函数的形参”都是私有变量；
		* 每个函数执行的时候都会生成一个私有的作用域，遇到变量看它是否用var定义或者是形参，那么这个变量为私有变量，如果它是私有变量，那么和外面没有任何关系，
		如果不是私有变量则往当前作用域的上级作用域进行查找，如果上级中没有一直找到window为止。
	8. 如何查找当前作用域的上一级作用域?
		* 看当前函数是在哪个作用域下定义的，那么它的上级作用域就是谁，和函数在哪儿执行没有任何关系

十、 闭包
	1. 如何产生闭包?
		* 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包
		* 闭包产生的个数=外部函数被调用的次数
	2. 闭包到底是什么?
		* 使用chrome调试查看
		* 理解一: 闭包是嵌套的内部函数(绝大部分人)
		* 理解二: 包含被引用变量(函数)的对象(极少数人)
		* 注意: 闭包存在于嵌套的内部函数中
	3. 产生闭包的条件?
		* 函数嵌套
		* 内部函数引用了外部函数的数据(变量/函数)
	4. 常见的闭包
		- 将函数作为另一个函数的返回值
			例子1：
			function fn1() {
				var a = 2
				function fn2() {
					a++
					console.log(a)
				}
				return fn2
			}
			var f = fn1()
			f() // 3
			f() // 4
		- 将函数作为实参传递给另一个函数调用
			例子2：
			function showDelay(msg, time) {
				setTimeout(function () {
					alert(msg)
				}, time)
			}
			howDelay('atguigu', 2000)
	5. 闭包的作用(上例1)
		- 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
		- 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
		- 问题：
			* 函数执行完后, 函数内部声明的局部变量是否还存在?  一般是不存在, 存在于闭中的变量才可能存在
			* 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它
	6. 闭包的生命周期
		- 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
		- 死亡: 在嵌套的内部函数成为垃圾对象时
		- 例子：
			function fn1() {
				//此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)
				var a = 2
				function fn2 () {
					a++
					console.log(a)
				}
				return fn2
			}
			var f = fn1()
			f() // 3
			f() // 4
			f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)
	7. 闭包的应用：定义JS模块
		* 具有特定功能的js文件
		* 将所有的数据和功能都封装在一个函数内部(私有的)
		* 只向外暴露一个包信n个方法的对象或函数
		* 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
		- 定义js模块2种方法
			方法一：
			* js模块通过return {}返回
			* 使用的时候先引入
			* 然后的先执行var module=myModule()
			* 才能使用 module.doSomething()
			方法二：
			* js模块利用匿名函数自调用(function (w) {})(window)
			* 通过w.myModule2={}返回
			* 使用的时候先引入
			* 然后就能直接使用 module2.doSomething()
	8. 闭包的缺点及解决
		- 缺点：
			* 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
			* 容易造成内存泄露
		- 解决：
			* 能不用闭包就不用
			* 及时释放  f = null //让内部函数成为垃圾对象-->回收闭包

			
十一、 内存溢出与内存泄漏
	1. 内存溢出
		* 一种程序运行出现的错误
		* 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误
	2. 内存泄露
		* 占用的内存没有及时释放
		* 内存泄露积累多了就容易导致内存溢出
		* 常见的内存泄露:
			* 意外的全局变量
			function fn() {
				a = new Array(10000000)  //定义a的时候没有用var
				console.log(a)
			}
			fn()
			* 没有及时清理的计时器或回调函数
			var intervalId = setInterval(function () { //启动循环定时器后不清理
				console.log('----')
			}, 1000)
			// clearInterval(intervalId)  //没有这句关闭计时器，会一直运行
			* 闭包
			function fn1() {
				var a = 4
				function fn2() {
					console.log(++a)
				}
				return fn2
			}
			var f = fn1()
			f()

			// f = null   //没有这句f=null，由于f一直引用，所以不会成为垃圾对象，不会进行回收

十二、 对象的创造模式
	1. Object构造函数模式
		* 套路: 先创建空Object对象, 再动态添加属性/方法
		* 适用场景: 起始时不确定对象内部数据
		* 问题: 语句太多
		例子：
			var p = new Object() 或者 p = {} //此时内部数据是不确定的
			p.name = 'Tom'
			p.age = 12
			p.setName = function (name) {
				this.name = name
			}
	2. 对象字面量模式
		* 套路: 使用{}创建对象, 同时指定属性/方法
		* 适用场景: 起始时对象内部数据是确定的
		* 问题: 如果创建多个对象, 有重复代码
		例子：
			var p = {
				name: 'Tom',
				age: 12,
				setName: function (name) {
					this.name = name
				}
			}
	3. 工厂模式
		* 套路: 通过工厂函数动态创建对象并返回
		* 适用场景: 需要创建多个对象
		* 问题: 对象没有一个具体的类型, 都是Object类型
		例子：
			function createPerson(name, age) { //返回一个对象的函数===>工厂函数
				var obj = {
				name: name,
				age: age,
				setName: function (name) {
						this.name = name
					}
				}

				return obj
			}
			// 创建2个人 （创建的都是Object对象，区分不了具体的类型）
			var p1 = createPerson('Tom', 12)
			var p2 = createPerson('Bob', 13)
	4. 自定义构造函数模式
		* 套路: 自定义构造函数, 通过new创建对象
		* 适用场景: 需要创建多个类型确定的对象
		* 问题: 每个对象都有相同的数据, 浪费内存(需要将方法，存放到原型对象中)
		* 扩展：a. 在构造函数中new Person ()执行 ，如果Person 不传入参数则后面的括号可以省略
			b. this的问题：在类中出现的this.xxx=xxx中的this都是当前类的实例，而某一个属性值(方法),方法中的this需要看方法执行的时候前面是否有"."来确定
			c. 类中也有普通函数一面，当函数执行时候，var num其实只是形成一个私有作用域中的私有变量而已，它和创建的实例对象没有任何关系，只有this.xxx=xxx才可以给当前的实例对象增加属性和方法
			d. 浏览器会自动返回实例(是一个对象数据类型的值)，如果我们手动写return返回;如果自己手动发返回一个基本数据类型的值，则对当前实例不会改变;如果手动返回一个引用数据类型的值，当前的实例对象会被替换掉
			e. 检测某一个实例是否属于这个类-->实例 instanceof 构造函数
		* 工厂模式和自定义构造函数模式有什么相同点和不同点？
			* 相同点：都是形成一个私有的作用域，然后形参赋值-->预解释-->代码从上到下执行
			* 不同点：a.在代码执行之前，不用再手动的创建obj对象，浏览器会默认自动创建。
				  b.已当前的实例当做执行的主体(this代表的就是当前的实例),我们给该对象添加属性和方法用this.方法来做
				  c.浏览器会默认的把创建的实例返回，不需要手动return返回
		例子：
			function Person(name, age) {
				this.name = name
				this.age = age
				this.setName = function (name) {
					this.name = name
				}
			}
			function Student (name, price) {
				this.name = name
				this.price = price
			}
			var s = new Student('Bob', 13000)
			var p1 = new Person('Tom', 12)
	5. 构造函数+原型的组合模式
		* 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上
		* 适用场景: 需要创建多个类型确定的对象
		例子：
			function Person(name, age) { //在构造函数中只初始化一般函数
				this.name = name
				this.age = age
			}
			Person.prototype.setName = function (name) {
				this.name = name
			}

			var p1 = new Person('Tom', 23)
			var p2 = new Person('Jack', 24)

十三、 原型链继承
	方式1: 原型链继承
		1. 套路
			a. 定义父类型构造函数
			b. 给父类型的原型添加方法
			c. 定义子类型的构造函数
			d. 创建父类型的对象赋值给子类型的原型
			e. 将子类型原型的构造属性设置为子类型
			f. 给子类型原型添加方法
			g. 创建子类型的对象: 可以调用父类型的方法
		2. 关键
			* 子类型的原型为父类型的一个实例对象
			* 可以把父类私有的和共有的都给子类
		例子：
			//a.定义父类型构造函数
			function Supper() {
				this.supProp = 'Supper property'
			}
			//b.给父类型原型添加方法
			Supper.prototype.showSupperProp = function () {
				console.log(this.supProp)
			}
			//c.定义子类型构造函数
			function Sub() {
				this.subProp = 'Sub property'
			}
			//d.子类型的原型为父类型的一个实例对象(关键)
			Sub.prototype = new Supper()
			//e.让子类型的原型的constructor指向子类型
			Sub.prototype.constructor = Sub
			//f.给子类型原型添加方法
			Sub.prototype.showSubProp = function () {
				console.log(this.subProp)
			}
			//g.创建子类型的对象: 可以调用父类型的方法
			var sub = new Sub()
			sub.showSupperProp()
	方式2: 借用构造函数继承(假的)
		1. 套路:
			a. 定义父类型构造函数
			b. 定义子类型构造函数
			c. 在子类型构造函数中调用父类型构造
		2. 关键:
			* 在子类型构造函数中通用call()调用父类型构造函数
			* 只能把父类私有的给子类
		例子：
			function Person (name ,age){
				this.name=name;
				this.age=age
			}
			function Student (name ,age ,price){
				Person.call(this ,name ,age)  //相当于this.Person (name ,age) (不这么写，因为其中并没有Person，所以要用call)
				//this.name = name;
				//this,age = age;
				this.price = price
			}
			var s =new Student ('Tom' ,20 , 14000)
			console.log (s.name ,s.age ,s.price)
	方式3：冒充对象继承：把父类私有的+公有的克隆一份一模一样的给子类私有的
		- 此方法在父类上在增加东西和子类没有任何关系
		例子：
			function A () {
				this.x =100;
			}
			A.prototype.getX = function () {
				console.log (this.x);
			};
			function B (){
				var temp = new A;
				for (var key in temp){  //这里没有添加判断，所以枚举的时候可以把公有的方法也枚举出来，如果添加判断可以只枚举私有
					this[key] = temp[key];
				}
				temp = null ;
			}
			var n = new B; //此时n将具有A的属性和方法
	方式4：原型链+借用构造函数的组合继承
		1. 利用原型链实现对父类型对象的方法继承
		2. 利用super()借用父类型构建函数初始化相同属性
		稍有不足的地方：子类的私有部分和公有部分prototype有一部分属性重复了，影响也不大也不会产生冲突。
		例子：
			function Person (name ,age ){
				this.name=name
				this.age=age
			}
			Person.prototype.setName =function (name){
				this.name=name
			}
			function Student(name ,age ,price){
				Person.call(this ,name ,age) // 为了得到属性
				this.price= price
			}
			Student.prototype = new Person () //为了能看到父类型的方法
			Student.prototype.constructor = Student //修正
			Student.prototype.setPrice =function (price){
				this.price =price
			}
			//使用
			var s =new Student ('Tom' ,24 ,15000)
			s.setName('Bob')
			s.setPrice(16000)
			console.log(s.name ,s.age ,s.price)
	方式5：寄生组合式继承
		1. 利用call、原型链继承、Object.create完成
		2. call只继承私有的属性，Object.create来继承公有的属性和方法
		代码：
			function A () {
				this.x =100;
			}
			A.prototype.getX = function () {
				console.log (this.x);
			};
			function B (){
				A.call(this);
			}
			B.prototype = objectCreate (A.prototype); //自己写的一个类似Object.create的方法 这里也可以直接写成B.prototype = Object.create (A.prototype);但是Object.create不支持IE6~8所以自己写了一个类似的方法
			B.prototype.constructor = B ; //修正
			var n = new B; //此时n将具有A的属性和方法
			function objectCreate(obj) {
				function Fn () {};
				Fn.prototype = obj ;
				return new Fn;
			}
	
十四、 进程与线程
	1. 进程：程序的一次执行, 它占有一片独有的内存空间
	2. 线程：CPU的基本调度单位, 是程序执行的一个完整流程
	3. 进程与线程
		* 一个进程中一般至少有一个运行的线程: 主线程
		* 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
		* 一个进程内的数据可以供其中的多个线程直接共享
		* 多个进程之间的数据是不能直接共享的
	4. 浏览器运行是单进程还是多进程?
		- 有的是单进程
			* firefox
			* 老版IE
		- 有的是多进程
			* chrome
			* 新版IE
	5. 如何查看浏览器是否是多进程运行的呢?
		* 任务管理器==>进程
	6. 浏览器运行是单线程还是多线程?
		* 都是多线程运行的

十五、 浏览器内核
	1. 什么是浏览器内核?
		* 支持浏览器运行的最核心的程序
	2. 不同的浏览器可能不太一样
		* Chrome, Safari: webkit
		* firefox: Gecko
		* IE: Trident
		* 360,搜狗等国内浏览器: Trident + webkit
	3. 内核由很多模块组成
		* html,css文档解析模块 : 负责页面文本的解析
		* dom/css模块 : 负责dom/css在内存中的相关处理
		* 布局和渲染模块 : 负责页面的布局和效果的绘制
		以上是主线程运行的，以下是分线程运行
		* 定时器模块 : 负责定时器的管理
		* 网络请求模块 : 负责服务器请求(常规/Ajax)
		* DOM事件响应模块 : 负责事件的管理

十六、 JS是单线程的
	1. 如何证明js执行是单线程的?
		* setTimeout()的回调函数是在主线程执行的
		* 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
			* 定时器并不能保证真正定时执行
			* 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)
	2. 为什么js要用单线程模式, 而不用多线程模式?
		* JavaScript的单线程，与它的用途有关。
		* 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。
		* 这决定了它只能是单线程，否则会带来很复杂的同步问题
	3. 代码的分类:
		* 初始化代码
		* 回调代码 （回调函数包含的代码，什么是回调函数：①你定义的②你没有调用③但是它最终执行了）
	4. js引擎执行代码的基本流程
		* 先执行初始化代码: 包含一些特别的代码   回调函数(异步执行：只有当所有的初始化代码执行完后才会看情况进行执行)
			* 设置定时器
			* 绑定事件监听
			* 发送ajax请求
		* 后面在某个时刻才会执行回调代码

十七、 事件循环模型
	1. 所有代码分类
		* 初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
		* 回调执行代码(异步代码): 处理回调逻辑
	2. js引擎执行代码的基本流程:
		* 初始化代码===>回调代码
	3. 模型的2个重要组成部分:
		* 事件(定时器/DOM事件/Ajax)管理模块
		* 回调队列
	4. 模型的运转流程
		* 执行初始化代码, 将事件回调函数交给对应模块管理
		* 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
		* 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行

十八、 Web Workers
	1. H5规范提供了js分线程的实现, 取名为: Web Workers
	2. 相关API
		* Worker: 构造函数, 加载分线程执行的js文件
		* Worker.prototype.onmessage: 用于接收另一个线程的回调函数
		* Worker.prototype.postMessage: 向另一个线程发送消息
	3. 不足
		* worker内代码不能操作DOM(更新UI)
		* 不能跨域加载JS
		* 不是每个浏览器都支持这个新特性

十九、 内存的释放
	- 不自行销毁作用域占用空间的情况(当前私有作用域的部分内存被作用域以外的东西占用了，那么当前的作用域就不能销毁)
		1. 函数执行返回了一个引用数据类型的值，并且在函数外面被一个其他的东西给接收了，就不会销毁。
			例子：
			function fn () {
				var num = 100 ;
				return function () {};
			}
			var f= fn (); //当前fn这个函数执行的作用域不会自动销毁
		2. 在一个私有的作用域中给DOM元素的事件绑定方法，一般情况下我们的私有作用域都不销毁
			例子：
			var div1 = document.getElementById ("div1");
			(function () {
				div1.onclick = function () {}
			}) (); //当前自执行函数形成的这个私有的作用域也不会销毁
	- 不立即销毁的情况(fn返回的函数没有被其他东西占用，但是还需要执行一次，所以暂时不销毁，当返回的值执行完成后，浏览器会在空闲的时候把它销毁)
		function fn () {
			var num = 100 ;
			return function () {} ;
		}
		fn ()();//首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行，小函数执行完成之后才会销毁作用域。

二十、 this
	- this的整体理解
		* 我们在js中主要研究的都是函数中的this，但是并不是说this只有函数中有
		* JS中的this代表的是当前行为执行的主体；JS中的context(执行上下文)代表的是当前行为执行的环境(区域);
		* this是谁和函数在哪儿定义的和在哪儿执行的都没有任何关系
	- 如何区分this
		1. 函数执行，首先看函数名前面是否有".",如果有的话，"."前面是谁this就是谁，没有的话this就是window
			例子：
			function fn () {
				console.log (this);
			}
			function sum (){
				sum里面的this是window
				fn (); //fn中的this是window
			}
			sum();
		2. 自执行函数中的this永远是window
		3. 给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前触发事件的元素
			例子：
			document.getElementById("div1").onclick = fn ; //fn中的this是#div1
			document.getElementById("div1").onclick = function () {
				这里面的this是#div1
				fn (); //fn中的this是window
			}
		4. 在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例
			例子：
			function Student (name, price) {
				this.name = name
				this.price = price
			}
		5. 使用call/apply来改变this的指向(一但遇到call/apply上述的四条都没用了)

二十一、 可枚举和不可枚举
	枚举对象中的属性 使用for ... in 语句  对象中有几个属性，循环体就会执行几次 每次执行时，会将对象中的一个属性的名字赋值给变量
	列如：for（var n in obj）{
		if(obj.propertyIsEnumerable(n)){  //表示可以枚举的属性 或者判断里面也可以写obj.hasOwnProperty(n) 私有的属性
			console.log(n);    obj是对象
			}
		 		 
	      }

二十二、 Object.create
	语法: var obj1 =Object.create(obj)
	解释：创建一个新的对象，但是还要把obj作为这个对象的原型 在IE6~8不兼容(ECMAScriot5新增)
	自己写一个原理类似的方法
		function objectCreate(obj) {
				function Fn () {};
				Fn.prototype = obj ;
				return new Fn;
			}

二十三、 call apply bind
	1. call
	- fn.call(obj);
	- call在原型链中的位置
		* call方法是Funcyion.prototype上的方法
	- call方法的作用
		* 首先我们让原型上的call方法执行，在执行call方法的时候，我们让fn方法中的this变为第1个参数值obj;然后在把fn这个函数执行
	- call方法的代码原理
		Function.prototype.myCall = function (context) {
			//eval(this.toString().replace("this","context")); 
			//1.this.toString()把要执行的函数转换成字符串，然后修改this为需要执行的对象，eval然后将字符串转换成js源码
		 	this();
			//2.让需要执行的函数执行
		}
	- call参数：
		* 第1个参数就是修改this的值，后面的参数都是这个函数的实参
		* 用"use strict"开启严格模式,严格模式下call的第1个参数有影响，第1个参数不传，则this是undefined，传unll则this是null，传入undefined则this是undefined
	- 例子理解：
		function fn1() {console.log(1);}
		function fn2() {console.log(1);}
		fn1.call(fn2);
		首先fn1通过原型链机制找到Function.prototype上的call方法，并且让call方法执行-->此时这个方法中的this就是我要操作的fn1-->在call方法代码执行的过程中首先让fn1中的"this关键字"变为fn2，然后在让fn1这个方法执行 -->1
		fn1.call.call(fn2);
		首先fn1通过原型链机制找到Function.prototype上的call方法，然后通过call方法通过原型在找到Function.prototype上的call方法(因为call本身也是函数，所以可以找到)，在第二次找到call方法的时候让方法执行，方法中的this是fn1.call,首先让这个方法中的this变成fn2,然后再让fn1.call执行，最终效果是执行fn2,因为将this()，改成了fn2()
	2.apply
		* apply和call方法的作用是一模一样的，只是传入参数的时候语法有所不同,apply是将参数方在一个数组中进行传递的。
		例子: fn1.call(fn2,1,2);  fn1.apply(fn2,[1,2]);
	3.bind
		var tempFn = fn.bind (obj , 1, 2);
		tempFn();
		* 只是改变了fn中的this为obj,并且给fn传递了两个参数，但是此时并没有执行fn;执行bind会有一个返回值，这个返回值tempFn就是我们把fn的this改变后的结果
		* 利用了预处理思想
	应用：
		如何将一个类数组转换成数组,比如arguments就是一个类数组转换为数组
		var arr = Array.prototype.slice.call(arguments);
		var arr = [].slice.call(arguments);

二十四、 try catch
	* 我们可以用try/catch捕获异常信息，不影响下面的代码继续执行;如果try中的代码执行出错了，会默认执行catch中的代码；
	try {
		console.log (num);
	} catch (e){//形参必须要写，一般起名为e
		console.log ("报错了",e.message);//e.message可以收集报错信息
		//手动抛出一个错误信息不让代码继续向下执行
		throw new Error("当前网络繁忙，请稍后再试");
		throw new ReferenceError 引用错误
		throw new TypeError 类型错误
		throw new RangeError 范围错误
	} finally {
		//一般不用：不管try中的代码是否报错，都要执行finally中的代码
	}

二十五、 数据绑定
	- 利用动态创建元素节点和把它追加到页面中的方式实现数据绑定
		var oUl = document.getElementById("ul1");
		var ilis = oUl.getElementsByTagName("li");
		for (var i=0;i<arr.length;i++){
			var cur = ary[i];
			var oLi = document.createElement("li");
			oLi.innnerHTML = "<span>"+(i+4)+"</span>"+cur.title;
			oUl.appendChild(oLi);
		}
		* 优势：把需要动态绑定的内容一个个的追加到页面中，对原来的元素没有任何的影响
		* 弊端：每当创建一个li，我们就添加到页面中，引发一次DOM的回流，最后引发回流的次数过多，影响我们的性能
	- 字符串拼接的方式：首先循环需要绑定的数据，然后把需要动态绑定的标签以字符串的方式拼接到一起，并且完成后，最后统一的添加到页面中。
		var str= "";
		for (var i=0;i<arr.length;i++) {
			var cur = ary[i];
			str += "<li>";
			str += "<span>"+(i+4)+"</span>";
			str += cur.title;
			str += "</li>";
		}
		oUl.innnerHTML += str;//先获取到之前页面中的html标签字符串，然后进行标签字符串拼接，最后统一的将其添加到页面中，浏览器还需要把字符串渲染成为对应的标签
		* 弊端：我们把新拼接的字符串添加到#ul1中，原来的三个li的鼠标滑过效果都消失了
		* 优势：事先把内容拼接好，最后统一添加到页面中，只引发一次回流
	- 文档碎片
		var frag = document.createDocumentFragment();//创建一个文档碎片
		for (var i=0;i<arr.length;i++){
			var cur = ary[i];
			var oLi = document.createElement("li");
			oLi.innnerHTML = "<span>"+(i+4)+"</span>"+cur.title;
			frag.appendChild(oLi);
		}
		oUl.appendChild(frag);
		frag = null;
	
二十六、 回流和重绘
	- 回流(重排reflow):当页面中的HTML结构发生变化(增加、删除元素、位置反生改变...)，浏览器都需要从新的计算一遍最新的DOM结构，从新的对当前的页面进行渲染
	- 重绘：当一个元素的部分样式发生改变了(背景颜色)，浏览器只需要重新的渲染当前元素即可。

二十七、 DOM的映射机制
	* 页面中的标签和JS中获取到的元素对象(元素集合)是紧紧的绑定在一起的,页面中的HTML结构改变了，JS中不需要重新获取，集合里面的内容也会跟着自动改变

二十八、检测数据类型
	- typeof 用来检测数据类型的运算符
		console.log (typeof 12);
		* 使用typeof检测数据类型，首先返回的结果都是一个字符串，其次字符串中包含了对应的数据类型，如:"number"、"string"、"boolean"、"undefined"、"function"、"object"
		* 局限性
			1.不能检测null ,typeof null -->"object"
			2.不能具体的细分是数组还是正则，还是对象中的其他的值，因为使用typeof检测数据类型，对于对象数据类型中最后的返回结果都是"object"。解决：可以用instanceof
		应用:
			fn(function(){})
			function fn (callback) {
				//typeof callback === "function" ? callback() :null;
				callback && callback ();
			}
	- instanceof 检测某一个实例是否属于某个类
		var obj = [12,32];
		console.log (obj instanceof Array);
		console.log (obj instanceof RegExp);
		* 返回值，如果obj是该构造函数的实例，则返回true,否则返回false;
		* 局限性
			1. 不能用来检测和处理字面量方式创建出来的基本数据类型值,解决：可以用new Number(1);还可以用constructor来判断
			解释：对于基本数据类型来说，字面量创建出来的结果和实例方式创建出来的结果是有一定的区别的,从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这个类的一个实例;对于字面量方式创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散特点，导致了可以使用Number.prototype上的方法；
			console.log (1 instanceof Number); //false;
			console.log (new Number(1) instanceof Number); //true
			2. instanceof 特性：只要在当前实例的原型链上，我们检测的结果都为true
			var arr = [];
			console.log (arr instanceof Array); //true;
			console.log (arr instanceof Object); //true;
			3. 在类的原型继承中，我们最后检测出来的结果未必准确，让子类的原型等于父类的一个实例
			function Fn (){}
			Fn.prototype = new Array;
			var f = new Fn;
			console.log (f instanceof Array) //true 但是f并不是一个数组
	- constructor 构造函数 作用和instanceof 非常的相似
		var obj = [];
		console.log (obj.constructor === Array); //true 
		console.log (obj.constructor === Object); //false 因为先找原型链上自己的，因为是数组，找到数组了所以不向后面找了
		console.log (obj.constructor === RegExp); //false
		* 返回值，根据原型链查找，先找自身的找到，没有继续查找，有则返回true,则不在向后面查找，所以找到后，后面的都返回false
		* constructor可以处理基本数据类型的检测(但是对于特殊的数据类型null和undefined，他们所属的类是Null和Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用)
		var num = 1;
		console.log (num.constructor === Number); //true
		* 局限性：
			我们可以把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的
	- Object.prototype.toString.call() 最准确最常用的方式,可以检测所有的数据类型
		* 首先获取Object原型上的toSring方法，让方法执行，并且改变方法中的this关键字的指向
		console.log (({}).toString.call(/^$/)); //"[object RegExp]"
		console.log (({}).toString.call(/^$/) === "[object RegExp]"); //true
		var reg = /^\[object RegExp\]$/;
		console.log (reg.test(Object.prototype.toString.call(/^$/))); //true

二十九、 toString方法
	- 理解：乍一看应该是转换为字符串，但是某些toString方法不仅仅是转换为字符串
		* Number.prototype.toString()方法是转换为字符串
			该toString(2/8/10)可以传入2 8 10参数，将数字转换为二进制、八进制、十进制的字符串
		console.log ((1).toString()); //"1"  利用的是Number.prototype.toString转换为字符串
	- 总结：
		* 对于Number、String、Boolean、Array、RegExp、Date、Function原型上的toString方法都是把当前的数据转换为字符串的类型
		* 但是Object.prototype.toString并不是用来转换字符串的，它的作用是返回当前方法执行主体(方法中this)所属类的详细信息
		var obj ={name:"bbdeng"}
		obj.toString() //"[object Object]" toString中的this是obj，返回的是obj所属类的信息-->第1个object代表当前实例是对象数据类型的(这个是固定死的),第二个Object，代表的是obj是Object这个类的一个实例
		Math.toString() //"[object Math]"  这2个都是用的Object.prototype.toString上的toString方法
	- 使用Object.prototype.toString.call()来检测数据类型：
		var ary = [];
		console.log (Object.prototype.toString.call(ary)) //"[object Array]"
		console.log (({}).toString.call(/^$/)); //"[object RegExp]"
		
三十、 定时器
	* 都是window的方法
	- setTimeout
		window.setTimeout(function(){},1000);
		设置一个定时器(setTimeout),等到1000ms后开始执行对应的方法，方法执行完成后，定时器结束
	- setInterval
		window.setInterval(function(){},1000);
		设置一个定时器(setInterval),等到1000ms后开始执行对应的方法，方法执行完成后，定时器并没有结束，以后每隔1000ms都会把定时器中的方法执行一次...直到手动清除定时器为止
	- 定时器的返回值，返回的结果是一个数字，代表当前是第几个定时器，而且setTimeout，setInterval会依次向后排序。
	- 清除定时器
		window.clearTimeout(1);
		window.clearTimeout(time1);
		window.clearInterval(1);
		2种方法都可以清除,清除定时器的时候，clearsetTimeout和clearsetInterval没有区别，只要传入的参数是对应定时器的都可以清除定时器
	- 用setTimeout结合递归调用来实现一个类似setInterval的功能
		var time = null ,n = 0;
		function move () {
			//每一次执行该方法，都会生成一个定时器，需要手动对定时器进行清除
			clearTimeout (time);
			n++;
			console.log (n);
			if ( n === 5) {
				return ; 
			}
			time = setTimeout (move , 1000);
		}
		move ();

三十一、 JS中的同步编程和异步编程
	- 同步编程
		* 上一件事情没有处理完成，继续处理上一件事情，只有上一件事情处理完成了，才会处理下一件事情(JS中大部分都是同步编程的)
		* 列入for循环,while循环
	- 异步编程
		* 规划要做一件事情，但是不是当前立马去执行，需要等一段时间，这样的话不会等它执行，而是先继续执行下面的操作，但是只有当下面的事情全部处理完成之后，才会回头来处理之前的事情，不管之前的事情有没有到指定的时间，都得等着。
		* JS中异步编程只有四种情况：定时器都是异步编程、所有的事件绑定都是异步编程的、Ajax读取数据的时候、回调函数也是异步编程的
	- 应用
		1. 首屏图片延迟加载
			* 样式方面：
				a. 图片外面包一个div容器
				b. 图片的src="",自定义一个属性保存真实src地址,trueSrc = "img/jd.jpg"
				c. 图片 width:100%;height:100%; display:none; 方式图片加载失败出现碎图图标
				d. 给包img的div容器设置宽高，边框，和背景加载图片background: url("") no-repeat center center ; 
			* JS代码方面：
				a. 设置一个定时器300ms延迟执行;
				b. 在定时器中创建一个新的img标签,oImg = new Image;oImg =document.createElement("img");
				c. 然后把img标签的真实地址赋值给新建oImg.src = img.getAttribute("trueSrc");
				d. 给oImg绑定onload的事件，如果能触发说明图片加载成功，然后在事件的回调函数中，将真实地址赋值给页面中的img标签,img.src = this.src; img.style.display = "block"; oImg = null;
				e. 在onload的事件外面可以处理图片正在加载中的事情。给每个img添加一个自定义属性isLoad = true;后期用于判断加载过就不在处理了

三十二、js工具包的封装和常用思想
	1.惰性函数
	* 能执行一次就搞定的绝对不会执行多次
	* 惰性函数，第1次计算得到的值，可以直接使用，然后用这个函数重置外部函数，以后就不用计算，也不用判断了。
		实例：
		function Max1() {return 1;}
		function Max2() {return 2;}
		function Max3() {return 3;}
		function getMax() {
		    var fns = [Max1,Max2,Max3];
		    var MaxFn = fns[0],max = fns[0]();
		    for (var i=1; i<fns.length; i++){
		        var val = fns[i]();
		        if (val > max){
		            max = val;
		            maxFn = fns[i];
		        }
		    }
		    getMax = maxFn;
		    return max;
		}
	2. 默认配置的extends继承
	* 用户输入的配置，修改掉默认的配置，但是不覆盖默认配置，默认配置下次还能继续使用
	var util = {
		extends:function(_default,config){ //_default默认属性，config用户输入的属性
			var result = {};
			for(var attr in _default){
				result[attr]=config[attr] || _default[attr];
			}
			return result;
		}
	}
	3. 柯里化函数
	*柯里化就是预先将某些参数传入，得到一个函数。但是预先传入的参数被保存在闭包中。
	应用：写一个判断数据类型的方法
	function isType(type){
		return function(obj){
			return Object.prototype.toString.call(obj) === '[object '+type+']'
		}
	}
	var util = {};
	var typeArr = ['Array','Object','Function','Date','RegExp']
	typeArr.forEach(function(type){
		util['is'+type] = isType(type);
	});
	使用
	util.isDate(new Date())  //true 
	4. 查询字符串
	* 将一个对象转换成一个&连接的查询字符串
	function to(data){
		return Object.keys(data).map(function(key){
			return key + '=' + data[key];
		}).join('&');
	}
	使用console.log(to({name:'zfpx',age:6}))  //'name=zfpx&age=6'
	5. encodeURIComponent 和 decodeURIComponent
	* url是ASCII码(只能表示128种字符)格式的，并且特殊字符有特殊含义
	* 需要把正常参数里的特殊字符和不能用ascii码表示的字符进行转义成十六进制的转义序列
	console.log(new Buffer('?'),encodeURIComponent('?')); // <Buffer 3f>   '%3F'
	console.log(new Buffer('中'),encodeURIComponent('中')); // <Buffer e4 b8 ad>   '%e4%b8%ad'
	转回来用decodeURIComponent()

三十三、 进制的转换
	1. 任意进制转换成10进制
	console.log(parseInt("11",2)); //3
	console.log(parseInt("11",8)); //9
	console.log(parseInt("11",16));//17
	2. 10进制转换成2 8 16 32进制
	console.log((3).toString(2)); //11
	console.log((9).toString(8)); //11
	console.log((17).toString(16)); //11
	console.log((33).toString(32)); //11
	注意：(33) 括号的作用是将一个number转换成对象,也可以这样写 33. 
三十四、Object.keys方法之详解
	* 在实际开发中，我们有时需要知道对象的所有属性，原生js给我们提供了一个很好的方法：Object.keys()，该方法返回一个数组
	1. 传入对象，返回属性名
		var obj = {'a':'123','b':'345'};
		console.log(Object.keys(obj));  //['a','b']
	2. 传入字符串，返回索引
		var str = 'ab1234';
		console.log(Object.keys(obj));  //[0,1,2,3,4,5]
	3. 构造函数 返回空数组或者属性名
		 function Pasta(name, age, gender) {
			this.name = name;
			this.age = age;
			this.gender = gender;
			this.toString = function () {
				return (this.name + ", " + this.age + ", " + this.gender);
			}
		}
		console.log(Object.keys(Pasta)); //console: []
		var spaghetti = new Pasta("Tom", 20, "male");
		console.log(Object.keys(spaghetti)); //console: ["name", "age", "gender", "toString"]
	4. 数组 返回索引
		var arr = ["a", "b", "c"];
		console.log(Object.keys(arr)); // console: ["0", "1", "2"]

三十五、 promise
	* 菜鸟教程http://www.runoob.com/w3cnote/javascript-promise-object.html
	* promise 表示一个异步操作的最终结果，与之进行交互的方式主要是then方法。
	* 跟状态有关， 初状态-->成功态 会执行成功的函数then()，并且把成功的数据当做参数传入
		       初状态-->失败态 会执行失败的函数fail()，并且把失败的原因当做参数传入
	
	
	* 简单原理代码
		//延迟对象  管理内部状态的
		var Defer = function (){
			var func;  //存储成功时候调用的函数，也就是then方法里面的参数回调
			var failFn;//存储失败时候调用的函数，也就是fail方法里面的参数回调
			return {
				resolve:function(data){ //异步操作成功
					func(data) //成功后调用成功的函数
				},
				reject:function(err){ //异步操作失败
					failFn(err) //失败后调用失败函数
				},
				promise:{
					then:function (fn1){ //promise有then方法
						func = fn1; //将then方法传递过来的函数保存到func，当成功的时候调用
						return this; //这里then是readFile调的，所以this是readFile，返回this是为了链式调用
					}
					fail:function (fn2){ //promise有fail方法
						failFn = fn2; //将fail方法传递过来的函数保存到failFn，当失败的时候调用
						return this; //这里fail是readFile调的，所以this是readFile，返回this是为了链式调用
					}

				}
			
			}
		}
		//模拟写一个readFile方法
		function readFile(filename,cb){
			var defer = Defer();
			fs.readFile(filename,'utf8',function(err,data){
				if(err){
					defer.reject(err); //读取文件失败时，调用失败函数
				}else{
					defer.resolve(data);//读取文件成功时，调用成功函数
				}
			})
			return defer.promise;
		}
		
		使用
		readFile('index.html').then(function(data){ //then成功时应该被调用的函数
			console.log(data);
		}).fail(function(err){ //fail失败时应该被调用的函数
			console.error(err);
		})

三十六、 ES6
	- 将ES6转换成ES5的插件
	babel-cli
	* 安装
	npm install babel-cli -g
	npm install --save-dev babel-preset-es2015
	* 配置文件
	在当前项目下创建一个后缀为 .babelrc的文件
	里面的内容为
	{
		"presets":["es2015"],
		"plugins":[]
	}
	* 将es6转换成es5
	babel app.js -o app.es5.js
	* babel常用命令
		* babel --help 常看帮助命令
		* babel -o 输出到一个文件 babel mobile.js -o build.js
		* babel -w 提供watch方法  babel -w mobile.js -o mobile.build.js
		* babel -s 生成sourcemap  babel -s -w mobile.js -o mobile.build.js
		* babel -d 指定要编译的目录 babel -d es5/ es6/ 

三十七、 JS模块化
	 - Browserify模块化使用教程(运行在浏览器)
	 * 下载browserify
	 	* 全局: npm install browserify -g
		* 局部: npm install browserify --save-dev
	 打包处理js:
	 	* browserify js/src/app.js -o js/dist/bundle.js  //-o 就是outout输出的意思
	

	


