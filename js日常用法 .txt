1.警告 alert(""); 
2.页面输出内容 document.write("");
3.向控制台输出console.log("");
4.变量赋值  var a=1243;
5.标识符规则 自主命名都可称标识符 
   规则： 1.含字母、数字、_、&
	  2.不能用数字开头
	  3.不能是ES中关键字或保留字
	  4.采用驼峰命名法
6.JS 中6种数据类型：
	String 	字符串    用""或者''不能混用   
			   \转移字符 \" 表示"   \'表示'  \n表示换行  \t表示制表符（相当于TAB键）  \\表示\		   		
	Number  数值      包括整数和浮点数（小数）
			  最大值Number.MAX_VALUE=1.7976931348623157e+308  超过最大值Infinity正无穷 -Infinity负无穷
			  最小是Number.MIN_VALUE=5e-324 无限接近0的最小数
			  NaN 是一个特殊的数值，表示Not A Number 
	Boolean 布尔值    只有2个  true 表示真  false表示假
	Null    空值      只有1个值就是null 专门用来表示空对象 用typeof检测类型反馈Object 
	Undefined 未定义  只有1个值就是undefined 用typeof检测返回undefined 定义过但是未赋值
	以上为基本数据类型

	下面为引用数据类型
	Object  对象
7.检查变量类型 语法： typeof 变量 列如：console.log(typeof a);
8.强制数据类型转换  
		1.将其他数据类型转换为String
		方法一：调用被转换数值类型的toString()方法 注：unll 和 undefined 这2个值没有toString方法
		方法二：调用String()函数 对于Number和Boolena其实就是调用toString()方法 对于null和undefined不会调用toString()方法 而是直接转换
		2.将其他数据类型装换为Number
		方法一：调用Number()函数 字符串--> 数字 1.纯数字字符串，直接转换为数字 2.含有非数字内容，转换为NaN 3.字符串是空串或者全是空格的字符串，转换为0
					 布尔-->数字 true 转换为1  false 转换为0
					 null-->数字  为0	
					 undefined-->数字 为NaN
		方法二：专门用来对付字符串
			parseInt() 把一个字符串转换为整数
			parseFloat() 把一个字符串转换为浮点数
			注:如果对非String使用以上 会先将其转换为String 然后在操作
		3.将其他数据类型转换为Boolean
			使用Boolean()函数 数字-->布尔 除了0和NaN其余全为true
					  字符串-->布尔 除了空串其余全为true
					  null和undefined转换为布尔为flase
					  对象转换为布尔为true 
9.其他的进制数字   在JS中，用0x开头表示16进制数字，如：0x10 输出为10进制16
			   用0开头表示8进制数字，如070 输出10进制56
		           用0b开头表示2进制数字（不是所有浏览器都支持），如0b10 输出10进制2
		   a=parseInt(a,10) 可以在parseInt（）中传递一个第二个参数，来指定数字的进制
10.运算符	typeof是一个运算符，可以获得一个值的类型，并将结果以字符串的形式返回
		算数运算符  除了加法 当对非Number类型的值进行运算时，会将值转换为Number然后在运算  注：任何值和NaN运算都得NaN
			+ 如果2个字符串进行加法运算，则会进行拼串，任何值和字符串相加，都会先转换为字符串，然后在拼串  可以给任意数据类型+""即可转换为String
			- 减法 *乘法 /除法  可以通过一个值-0 *1 /1来转换Number
			% 取模运算（取余数）
11.一元运算符 + 正号 不会对数字产生任何影响
	      - 负号 负号可以对数字进行负号取反
	      对于非Number的数据类型 会先转换成Number在运算。 对其他数据类型使用+将其装换为number
	      typeof 变量
12.自增和自减（课程17）  a++和++a 对于一个变量自增以后，原变量的值会立即自增1 但是a++的值为原变量的值（自增前的值） ++a的值为原变量的新值（自增后的值） 
13.逻辑运算符   !
			- 非运算可以对一个布尔值进行取反，true变false false边true
			- 当对非布尔值使用!时，会先将其转换为布尔值然后再取反
			- 我们可以利用!来将其他的数据类型转换为布尔值
		
		&&
			- &&可以对符号两侧的值进行与运算
			- 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。
			- 与是一个短路的与，如果第一个值是false，则不再检查第二个值
			- 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值
			- 规则：
					1.如果第一个值为false，则返回第一个值
					2.如果第一个值为true，则返回第二个值
		
		||
			- ||可以对符号两侧的值进行或运算
			- 只有两端都是false时，才会返回false。只要有一个true，就会返回true。
			- 或是一个短路的或，如果第一个值是true，则不再检查第二个值
			- 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值
			- 规则：	
					1.如果第一个值为true，则返回第一个值
					2.如果第一个值为false，则返回第二个值
14.赋值运算符
		= 
			- 可以将符号右侧的值赋值给左侧变量
			
		+=
			- a += 5 相当于 a = a+5
			- var str = "hello";  str += "world";
			
		-=
			- a -= 5  相当于 a = a-5
			
		*=
			- a *= 5 相当于 a = a*5
			
		/=
			- a /= 5 相当于 a = a/5	
	
		%=
			- a %= 5 相当于 a = a%5	
15.关系运算符
		- 关系运算符用来比较两个值之间的大小关系的
			>
			>=
			<
			<=
		- 关系运算符的规则和数学中一致，用来比较两个值之间的关系，
			如果关系成立则返回true，关系不成立则返回false。
		- 如果比较的两个值是非数值，会将其转换为Number然后再比较。
		- 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。  
16.utf-8编码如何使用   在script中 <script> \u四位编码(16进制)   </script>    在页面中<body> &#编码（10进制，需要转换用计算器）; </body>
17.相等运算符	==
			- 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false
			- 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，
				转换后相等它也会返回true
		!=
			- 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false
			- 不等也会做自动的类型转换。
			
		===
			- 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，
				如果两个值的类型不同，则直接返回false
				
		!==
			- 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true
			
		特殊的值：
			- null和undefined
				- 由于undefined衍生自null，所以null == undefined 会返回true。
					但是 null === undefined 会返回false。
					
			- NaN
				- NaN不与任何值相等，包括它自身 NaN == NaN //false
				
			- 判断一个值是否是NaN
				- 使用isNaN()函数
18.三元运算符：?:
			- 语法：条件表达式?语句1:语句2;
			- 执行流程：
				先对条件表达式求值判断，
					如果判断结果为true，则执行语句1，并返回执行结果
					如果判断结果为false，则执行语句2，并返回执行结果
19.流程控制语句
	- 程序都是自上向下的顺序执行的，
		通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。
	- 分类：
		1.条件判断语句
		2.条件分支语句
		3.循环语句
		
	条件判断语句
		- 条件判断语句也称为if语句
		- 语法一：
			if(条件表达式){
				语句...
			}
			
			- 执行流程：
				if语句执行时，会先对条件表达式进行求值判断，
					如果值为true，则执行if后的语句
					如果值为false，则不执行
		- 语法二：
			if(条件表达式){
				语句...
			}else{
				语句... 
			}
			
			- 执行流程：
				if...else语句执行时，会对条件表达式进行求值判断，
					如果值为true，则执行if后的语句
					如果值为false，则执行else后的语句
			
		- 语法三：
			if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else{
				语句...
			}
			
			- 执行流程
				- if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断，
					如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。
					如果判断结果为false，则继续向下判断，直到找到为true的为止。
					如果所有的条件表达式都是false，则执行else后的语句
20.条件分支语句
	- switch语句
	- 语法:
		switch(条件表达式){
			case 表达式:
				语句...
				break;
			case 表达式:
				语句...
				break;
			case 表达式:
				语句...
				break;
			default:
				语句...
				break;
		}
		
	- 执行流程：
		- switch...case...语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较，
			如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。
			如果所有的case判断结果都为false，则从default处开始执行代码。
21.循环语句
	- 通过循环语句可以反复执行某些语句多次
	- while循环
		- 语法：
			while(条件表达式){
				语句...
			}
			
		- 执行流程：
			while语句在执行时，会先对条件表达式进行求值判断，
				如果判断结果为false，则终止循环
				如果判断结果为true，则执行循环体
				循环体执行完毕，继续对条件表达式进行求值判断，依此类推
				
	- do...while循环
		- 语法:
			do{
				语句...
			}while(条件表达式)
			
		- 执行流程
			do...while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断，
				如果判断判断结果为false，则终止循环。
				如果判断结果为true，则继续执行循环体，依此类推
				
		- 和while的区别：
			while：先判断后执行
			do...while: 先执行后判断
			- do...while可以确保循环体至少执行一次。
			
			
	- for循环
		- 语法：
			for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){
				③语句...
			}
		- 执行流程：
			首先执行①初始化表达式，初始化一个变量，
			然后对②条件表达式进行求值判断，如果为false则终止循环
			如果判断结果为true，则执行③循环体
			循环体执行完毕，执行④更新表达式，对变量进行更新。
			更新表达式执行完毕重复②
			
	- 死循环
		while(true){
		
		}
		
		for(;;){
		
		}
提升性能:
	break 可以退出switch语句或循环语句,不能在if语句中使用break和continue,终止距离最近的循环语句
	label:循环语句  然后在break label;可以结束想要的循环
	continue跳过当次循环
	开方Math.sqrt()



22.总结类型转换 1.转换为String a.调用被转换函数类型的tostring（）方法
			       b.string()函数
			       c.+""加空串	       
		2.转换为Number a.Number（）函数
			       b.parseInt()  和parseFloat()
			       c.-0 *1 /1
			       d.+    直接前面添加一元运算符
		3.转换为Boolean a.Boolean()函数
				b.! !  
23.开启计时器测量时间 console.time("计时器的名字") 需要一个字符串作参数，用字符串给计时器进行表示 结束用console.timeEnd("")
24.对象（Object）
	- 对象是JS中的引用数据类型
	- 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性
	- 使用typeof检查一个对象时，会返回object
	对象的分类：1.内建对象：由ES标准中定义的对象，在ES实现中都可以使用，如：Math String Number Function.....
		    2.宿主对象：在JS运行环境提供的对象，目前主要讲由浏览器提供的对象.如BOM组 DOM组。
		    3.自定义对象：由开发人员自己创建的对象。
25.     - 创建对象
		- 方式一：
			- var obj = new Object();
		- 方式二：
			- var obj = {};
			
	- 向对象中添加属性
		- 语法：
			对象.属性名 = 属性值;
			对象["属性名"] = 属性值;
			
			- 对象的属性名没有任何要求，不需要遵守标识符的规范，
				但是在开发中，尽量按照标识符的要求去写。
			- 属性值也可以任意的数据类型。

	- 读取对象中的属性
		- 语法：
			对象.属性名
			对象["属性名"]
		- 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined
		
	- 删除对象中的属性
		- 语法：
			delete 对象.属性名
			delete 对象["属性名"]
	- 使用in检查对象中是否含有指定属性
		- 语法："属性名" in 对象
			- 如果在对象中含有该属性，则返回true
				如果没有则返回false
	- 使用对象字面量，在创建对象时直接向对象中添加属性
		语法：
			var obj = {
							属性名:属性值,
							属性名:属性值,
							属性名:属性值,
							属性名:属性值
					}
					
	- 基本数据类型和引用数据类型
		- 基本数据类型
			String Number Boolean Null Undefined
		- 引用数据类型
			Object
		- 基本数据类型的数据，变量是直接保存的它的值。
			变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。
		- 引用数据类型的数据，变量是保存的对象的引用（内存地址）。
			如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。
		- 比较两个变量时，对于基本数据类型，比较的就是值，
			对于引用数据类型比较的是地址，地址相同才相同

26.函数（Function）	
	- 函数也是一个对象，也具有普通对象的功能
	- 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码
	- 使用typeof检查一个函数时会返回function
	- 创建函数
		- 函数声明
			function 函数名([形参1,形参2...形参N]){
				语句...
			}
		
		- 函数表达式
			var 函数名 = function([形参1,形参2...形参N]){
				语句...
			};
			
	- 调用函数
		- 语法：函数对象([实参1,实参2...实参N]);
			fun() sum() alert() Number() parseInt()
		- 当我们调用函数时，函数中封装的代码会按照编写的顺序执行
		
		- call()
		- apply()
		- 这两个方法都是函数对象的方法需要通过函数对象来调用
		- 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this
		- 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递

	- 形参和实参
		- 形参：形式参数
			- 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开
				定义形参就相当于在函数内声明了对应的变量但是并不赋值，
				形参会在调用时才赋值。
				
		- 实参：实际参数
			- 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,
				调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。
				如果实参的数量大于形参，多余实参将不会赋值，
				如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined
	
	- arguments
		- arguments和this类似，都是函数中的隐含的参数
		- arguments是一个类数组元素，它用来封装函数执行过程中的实参
			所以即使不定义形参，也可以通过arguments来使用实参
		- arguments中有一个属性callee表示当前执行的函数对象
	
27.
	- 返回值，就是函数执行的结果。
		- 使用return 来设置函数的返回值。
		- 语法：return 值;
			- 该值就会成为函数的返回值，可以通过一个变量来接收返回值
		- return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。
		- return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。
		- 如果return后不跟值，或者是不写return则函数默认返回undefined。
		- break、continue和return
			- break
				- 退出循环
			- continue
				- 跳过当次循环
			- return
				- 退出函数
				
	- 参数，函数的实参也可以是任意的数据类型（对象，函数）。

	- 方法（method）
		- 可以将一个函数设置为一个对象的属性，
			当一个对象的属性是一个函数时，
				我们称这个函数是该对象的方法。
		- 对象.方法名();
		- 函数名();
28.枚举对象中的属性 使用for ... in 语句  对象中有几个属性，循环体就会执行几次 每次执行时，会将对象中的一个属性的名字赋值给变量
	列如：for（var n in obj）{
		 console.log(n);		   obj是对象
	      }
29.作用域
	- 作用域简单来说就是一个变量的作用范围。
	- 在JS中作用域分成两种：
		1.全局作用域
			- 直接在script标签中编写的代码都运行在全局作用域中
			- 全局作用域在打开页面时创建，在页面关闭时销毁。
			- 全局作用域中有一个全局对象window，window对象由浏览器提供，
				可以在页面中直接使用，它代表的是整个的浏览器的窗口。
			- 在全局作用域中创建的变量都会作为window对象的属性保存
				在全局作用域中创建的函数都会作为window对象的方法保存
			- 在全局作用域中创建的变量和函数可以在页面的任意位置访问。
				在函数作用域中也可以访问到全局作用域的变量。
			- 尽量不要在全局中创建变量	
		2.函数作用域
			- 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。
			- 函数作用域在函数执行时创建，在函数执行结束时销毁。
			- 在函数作用域中创建的变量，不能在全局中访问。
			- 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，
				如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，
					如果找到了则使用，找不到则继续向上找，一直会
					
		- 变量的声明提前
			- 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。
				所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。
			- 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，
				如果没有使用var关键字声明变量，则变量会变成全局变量
				
		- 函数的声明提前
			- 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，
				也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性
			- 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。
30.  this（上下文对象）	
	- 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。
		使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。
	- this的不同的情况：
		1.以函数的形式调用时，this是window
		2.以方法的形式调用时，this就是调用方法的对象
		3.以构造函数的形式调用时，this就是新创建的对象
		4.使用call和apply调用时，this是指定的那个对象
		5.在全局作用域中this代表window
31.使用工厂的方法创建对象 详细请看课程63
32.构造函数
	- 构造函数是专门用来创建对象的函数
	- 一个构造函数我们也可以称为一个类
	- 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例
	- 通过同一个构造函数创建的对象，我们称为一类对象
	- 构造函数就是一个普通的函数，只是他的调用方式不同，
		如果直接调用，它就是一个普通函数
		如果使用new来调用，则它就是一个构造函数
		
	- 例子：
		function Person(){
		
		}
		
	- 构造函数的执行流程：
		1.创建一个新的对象
		2.将新的对象作为函数的上下文对象（this）
		3.执行函数中的代码
		4.将新建的对象返回
		
	- instanceof 用来检查一个对象是否是一个类的实例
		- 语法：对象 instanceof 构造函数
			- 如果该对象时构造函数的实例，则返回true，否则返回false
			- Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true
			
	- 枚举对象中的属性
		for...in
		语法：
			for(var 属性名 in 对象){
			
			}
			
		for...in语句的循环体会执行多次，对象中有几个属性就会执行几次，
			每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性
33.原型（prototype）
	- 创建一个函数以后，解析器都会默认在函数中添加一个数prototype
		prototype属性指向的是一个对象，这个对象我们称为原型对象。
	- 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。
		这个隐含的属性可以通过  对象.__proto__  来访问。

	- 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。
		我们可以将对象中共有的属性和方法统一添加到原型对象中，
			这样我们只需要添加一次，就可以使所有的对象都可以使用。
	- 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，
		如果在自身中找到了，则直接使用。
		如果没有找到，则去原型对象中寻找，如果找到了则使用，
		如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null，
		如果依然没有找到则返回undefined
	- hasOwnProperty()
		- 这个方法可以用来检查对象自身中是否含有某个属性
		- 语法：对象.hasOwnProperty("属性名")
34.垃圾回收  将不在使用的对象设置为null  obj=null;
35.数组（Array）
	- 数组也是一个对象，是一个用来存储数据的对象
		和Object类似，但是它的存储效率比普通对象要高
	- 数组中保存的内容我们称为元素	
	- 数组使用索引（index）来操作元素
	- 索引指由0开始的整数
	-检查一个对象是不是数组 Array.isArray();  ()中填写要检查的对象
	- 数组的操作：
		- 创建数组
			- var arr = new Array();
			- var arr = [];
			
		- 向数组中添加元素
			- 语法；
				数组对象[索引] = 值;
				arr[0] = 123;
				arr[1] = "hello";
				
		- 创建数组时直接添加元素
			- 语法：
				var arr = [元素1,元素2....元素N];
				- 例子：
					var arr = [123,"hello",true,null];
					
		- 获取和修改数组的长度
			- 使用length属性来操作数组的长度
			- 获取长度：
				数组.length
				- length获取到的是数组的最大索引+1
				- 对于连续的数组，length获取到的就是数组中元素的个数
			- 修改数组的长度
				数组.length = 新长度
					- 如果修改后的length大于原长度，则多出的部分会空出来
					- 如果修改后的length小于原长度，则原数组中多出的元素会被删除
			- 向数组的最后添加元素
				数组[数组.length] = 值; 
		- 数组的方法
		- push()
			- 用来向数组的末尾添加一个或多个元素，并返回数组新的长度
			- 语法：数组.push(元素1,元素2,元素N)
		- pop()
			- 用来删除数组的最后一个元素，并返回被删除的元素
		- unshift()
			- 向数组的前边添加一个或多个元素，并返回数组的新的长度
		- shift()
			- 删除数组的前边的一个元素，并返回被删除的元素
		- slice()
			- 可以从一个数组中截取指定的元素
			- 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回
			- 参数：
				1.截取开始位置的索引（包括开始位置）
				2.截取结束位置的索引（不包括结束位置）
					- 第二个参数可以省略不写，如果不写则一直截取到最后
				- 参数可以传递一个负值，如果是负值，则从后往前数
		- splice()
			- 可以用来删除数组中指定元素，并使用新的元素替换
				该方法会将删除的元素封装到新数组中返回
			- 参数：
				1.删除开始位置的索引
				2.删除的个数
				3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边
		- reverse()
		- 可以用来反转一个数组，它会对原数组产生影响
		- concat()
		- 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回
		- join()
		- 可以将一个数组转换为一个字符串
		- 参数：
			需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素
			如果不指定连接符则默认使用,
		- sort()
		- 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序
			调用以后，会直接修改原数组。
		- 可以自己指定排序的规则，需要一个回调函数作为参数：
			function(a,b){
				
				//升序排列
				//return a-b;
				
				//降序排列
				return b-a;
			}
		- 遍历数组
		- 遍历数组就是将数组中元素都获取到
		- 一般情况我们都是使用for循环来遍历数组：
			for(var i=0 ; i<数组.length ; i++){
				//数组[i]
			}
			
		- 使用forEach()方法来遍历数组（不兼容IE8）
		
			数组.forEach(function(value , index , obj){
			
			});
			
			forEach()方法需要一个回调函数作为参数，
				数组中有几个元素，回调函数就会被调用几次，
				每次调用时，都会将遍历到的信息以实参的形式传递进来，
				我们可以定义形参来获取这些信息。
				value:正在遍历的元素
				index:正在遍历元素的索引
				obj:被遍历对象
36.Date
	- 日期的对象，在JS中通过Date对象来表示一个时间
	- 创建对象
		- 创建一个当前的时间对象
			var d = new Date();
		- 创建一个指定的时间对象
			var d = new Date("月/日/年 时:分:秒");
			
	- 方法：
		getDate()
			- 当前日期对象是几日（1-31）
			
		getDay() 
			- 返回当前日期对象时周几（0-6）
				- 0 周日
				- 1 周一 。。。
				
		getMonth()
			- 返回当前日期对象的月份（0-11）
			- 0 一月 1 二月 。。。
		getFullYear() 从 Date 对象以四位数字返回年份。 
		
		getHours() 返回 Date 对象的小时 (0 ~ 23)。 
		getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 
		getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 
		getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 
		
		getTime()
			- 返回当前日期对象的时间戳
			- 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数
				计算机底层保存时间都是以时间戳的形式保存的。
				
		Date.now()
			- 可以获取当前代码执行时的时间戳
37.Math			
	- Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法
		我们可以直接使用它来进行数学运算相关的操作
	- 方法：
		Math.PI
			- 常量，圆周率
		Math.abs()
			- 绝对值运算
		Math.ceil()
			- 向上取整
		Math.floor()
			- 向下取整
		Math.round()
			- 四舍五入取整
		Math.random()	
			- 生成一个0-1之间的随机数
			- 生成一个x-y之间的随机数
				Math.round(Math.random()*(y-x)+x);
		Math.pow(x,y)
			- 求x的y次幂
		Math.sqrt()
			- 对一个数进行开方
		Math.max()
			- 求多个数中最大值
		Math.min()
			- 求多个数中的最小值
38.包装类		
	- 在JS中为我们提供了三个包装类：
		String() Boolean() Number()
		- 通过这三个包装类可以创建基本数据类型的对象
		例子：
			var num = new Number(2);
			var str = new String("hello");
			var bool = new Boolean(true);
		- 但是在实际应用中千万不要这么干。
	
	- 当我们去操作一个基本数据类型的属性和方法时，
		解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，
		操作完成以后再将这个临时对象进行销毁。
39.字符串的相关的方法
	length
		- 获取字符串的长度
	charAt()
		- 根据索引获取指定的字符
	charCodeAt()
		- 根据索引获取指定的字符编码
	String.fromCharCode()
		- 根据字符编码获取字符
	indexOf()
	lastIndexOf()
		- 从一个字符串中检索指定内容
		- 需要一个字符串作为参数，这个字符串就是要检索的内容，
			如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。
		- 可以指定一个第二个参数，来表示开始查找的位置
		- indexOf()是从前向后找
		- lastIndexOf()是从后向前找
	slice()
		- 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量
		- 参数：
			第一个：截取开始的位置（包括开始）
			第二个：截取结束的位置（不包括结束）
				- 可以省略第二个参数，如果省略则一直截取到最后
			- 可以传负数，如果是负数则从后往前数
	substr()	
		- 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量
		
	substring()
		- 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，
			substring()中如果第二个参数小于第一个，自动调整位置
	toLowerCase() 
		- 将字符串转换为小写并返回
	toUpperCase() 
		- 将字符串转换为大写并返回
	split()
		- 可以根据指定内容将一个字符串拆分为一个数组
		- 参数：
			- 需要一个字符串作为参数，将会根据字符串去拆分数组
				可以接收一个正则表达式，此时会根据正则表达式去拆分数组
				
	match() 
		- 可以将字符串中和正则表达式匹配的内容提取出来
		- 参数：
			- 正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来
					并且封装到一个数组中返回
	
	replace()  
		- 可以将字符串中指定内容替换为新的内容
		- 参数：
			- 第一个：被替换的内容，可以是一个正则表达式
			- 第二个：替换的新内容
			
	search() 
		- 可以根据正则表达式去字符串中查找指定的内容
		- 参数：
			正则表达式，将会根据该表达式查询内容，
					并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1。
40.正则表达式 RegExp
	- 正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，
		也可以将一个字符串中符合规则的内容提取出来。
	- 创建正则表达式
		- var reg = new RegExp("正则","匹配模式");
		- var reg = /正则表达式/匹配模式
		
	- 语法：
		匹配模式：
			i:忽略大小写
			g:全局匹配模式
			- 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求
			
		正则语法		
			| 或
			[] 或
			[^ ] 除了
			[a-z] 小写字母
			[A-Z] 大写字母
			[A-z] 任意字母
			[0-9] 任意数字
		- 量词
			{n} 正好n次
			{m,n} m-n次
			{m,} 至少m次
			+	至少1次 {1,}
			?   0次或1次 {0,1}
			*   0次或多次 {0,}

			
		- 转义字符
			\ 在正则表达式中使用\作为转义字符
			\. 表示.
			\\ 表示\
			. 表示任意字符
			\w	  字母 数字 _
				- 相当于[A-z0-9_]
			\W	  除了字母 数字 _
				- 相当于[^A-z0-9_]
			\d        任意数字
				- 相当于[0-9]
			\D	  除了数字
				- 相当于[^0-9]
			\s
				- 空格
			\S
				- 除了空格
			\b
				- 单词边界
			\B
				- 除了单词边界
		^ 表示开始
		$ 表示结束
			
	- 方法：
		test()
			- 可以用来检查一个字符串是否符合正则表达式
			- 如果符合返回true，否则返回false
		-练习相关：1.例如：手机号正则表达式 var phoneReg=/^1[3-9][0-9]{9}$/
			   2.去除开头和结尾的全部空格 str.replace(/^\s*|\s*$/g,"");
			   3.邮件格式  var emailReg=/^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/;
41.DOM
	- Document Object Model
	- 文档对象模型，通过DOM可以来任意来修改网页中各个内容
	- 文档
		- 文档指的是网页，一个网页就是一个文档
	- 对象
		- 对象指将网页中的每一个节点都转换为对象
			转换完对象以后，就可以以一种纯面向对象的形式来操作网页了
	- 模型
		- 模型用来表示节点和节点之间的关系，方便操作页面
	- 节点（Node）
		- 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点
		- 虽然都是节点，但是节点的类型却是不同的
		- 常用的节点
			- 文档节点 （Document），代表整个网页
			- 元素节点（Element），代表网页中的标签
			- 属性节点（Attribute），代表标签中的属性
			- 文本节点（Text），代表网页中的文本内容
			
	- DOM操作
		- DOM查询
		- 在网页中浏览器已经为我们提供了document对象，
			它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。
		- document查询方法：
			- 根据元素的id属性查询一个元素节点对象：
				- document.getElementById("id属性值");
			- 根据元素的name属性值查询一组元素节点对象:
				- document.getElementsByName("name属性值");
			- 根据标签名来查询一组元素节点对象：
				- document.getElementsByTagName("标签名");
				
		- 元素的属性：
			- 读取元素的属性：
				语法：元素.属性名
				例子：ele.name  
					  ele.id  
					  ele.value 
					  ele.className
					  
			- 修改元素的属性：
				语法：元素.属性名 = 属性值
				
			- innerHTML
				- 使用该属性可以获取或设置元素内部的HTML代码
				
				
	- 事件（Event）
		- 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。
		- 我们可以为事件来绑定回调函数来响应事件。
		- 绑定事件的方式：
			1.可以在标签的事件属性中设置相应的JS代码
				例子：
					<button onclick="js代码。。。">按钮</button>
			2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件
				例子：
					<button id="btn">按钮</button>
					<script>
						var btn = document.getElementById("btn");
						btn.onclick = function(){
						
						};
					</script>
					
	- 文档的加载
		- 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。
		- 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，
			此时将会无法正常获取到DOM对象，导致DOM操作失败。
		- 解决方式一：
			- 可以将js代码编写到body的下边
			<body>
				<button id="btn">按钮</button>
				<script>
					var btn = document.getElementById("btn");
					btn.onclick = function(){
					
					};
				</script>
			</body>
			
		- 解决方式二：
			- 将js代码编写到window.onload = function(){}中
			- window.onload 对应的回调函数会在整个页面加载完毕以后才执行，
				所以可以确保代码执行时，DOM对象已经加载完毕了
			<script>
				window.onload = function(){
					var btn = document.getElementById("btn");
					btn.onclick = function(){
					
					};
				};
			
			</script>	
42.DOM查询
	- 通过具体的元素节点来查询
		- 元素.getElementsByTagName()
			- 通过标签名查询当前元素的指定后代元素
			
		- 元素.childNodes
			- 获取当前元素的所有子节点
			- 会获取到空白的文本子节点
		
		- 元素.children
			- 获取当前元素的所有子元素
		
		- 元素.firstChild
			- 获取当前元素的第一个子节点
		
		- 元素.lastChild
			- 获取当前元素的最后一个子节点
		
		- 元素.parentNode
			- 获取当前元素的父元素
		
		- 元素.previousSibling
			- 获取当前元素的前一个兄弟节点
		
		- 元素.nextSibling
			- 获取当前元素的后一个兄弟节点
	- document对象的其他的属性和方法
		document.all
			- 获取页面中的所有元素，相当于document.getElementsByTagName("*");
			
		document.documentElement
			- 获取页面中html根元素
			
		document.body
			- 获取页面中的body元素
			
		document.getElementsByClassName("")
			- 根据元素的class属性值查询一组元素节点对象
			- 这个方法不支持IE8及以下的浏览器
			
		document.querySelector("")
			- 根据CSS选择器去页面中查询一个元素
			- 如果匹配到的元素有多个，则它会返回查询到的第一个元素	
			
		document.querySelectorAll("")	例如 var div=document.querySelectorAll(".box1 div")
			- 根据CSS选择器去页面中查询一组元素
			- 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个
			
	innerHTML和innerText
		- 这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性
		- 两个属性作用类似，都可以获取到标签内部的内容，
			不同是innerHTML会获取到html标签，而innerText会自动去除标签
		- 如果使用这两个属性来设置标签内部的内容时，没有任何区别的	
		
	读取标签内部的文本内容
		<h1>h1中的文本内容</h1>
		元素.firstChild.nodeValue

		DOM修改
	document.createElement()
		- 可以根据标签名创建一个元素节点对象
		
	document.createTextNode()
		- 可以根据文本内容创建一个文本节点对象
		
	父节点.appendChild(子节点)
		- 向父节点中添加指定的子节点
		
	父节点.insertBefore(新节点,旧节点)
		- 将一个新的节点插入到旧节点的前边
		
	父节点.replaceChild(新节点,旧节点)
		- 使用一个新的节点去替换旧节点
		
	父节点.removeChild(子节点)
		- 删除指定的子节点
		- 推荐方式：子节点.parentNode.removeChild(子节点)
43.DOM对CSS的操作
	- 读取和修改内联样式
		- 使用style属性来操作元素的内联样式
		- 读取内联样式：  只能读取内联样式，不能读取style中的样式（当前样式）
			语法：元素.style.样式名
			- 例子：
				元素.style.width
				元素.style.height
				- 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法
					将-去掉，然后-后的字母改大写
				- 比如：background-color --> backgroundColor
						border-width ---> borderWidth
						
		- 修改内联样式：
			语法：元素.style.样式名 = 样式值
			- 通过style修改的样式都是内联样式，由于内联样式的优先级比较高，
				所以我们通过JS来修改的样式，往往会立即生效，
				但是如果样式中设置了!important，则内联样式将不会生效。
				
	- 读取元素的当前样式   课程109课  不仅仅可以读取当前样式
		- 正常浏览器
			- 使用getComputedStyle()
			- 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式
			- 参数：
				1.要获取样式的元素
				2.可以传递一个伪元素，一般传null
			- 例子：
				获取元素的宽度
					getComputedStyle(box , null)["width"];
			- 通过该方法读取到样式都是只读的不能修改

		- IE8
			- 使用currentStyle
			- 语法：
				元素.currentStyle.样式名
			- 例子：
				box.currentStyle["width"]
			- 通过这个属性读取到的样式是只读的不能修改
		-综合自写的查看样式的代码
		function getStyle(obj , name){
				
				if(window.getComputedStyle){
					//正常浏览器的方式，具有getComputedStyle()方法
					return getComputedStyle(obj , null)[name];
				}else{
					//IE8的方式，没有getComputedStyle()方法  注意：IE中如果没有设置属性会返回auto 可以设置属性为0
					return obj.currentStyle[name];
				}
				
				
				
			}




		- 其他的样式相关的属性
		注意：以下样式都是只读的
	
		clientHeight
			- 元素的可见高度，指元素的内容区和内边距的高度
		clientWidth
			- 元素的可见宽度，指元素的内容区和内边距的宽度
		offsetHeight
			- 整个元素的高度，包括内容区、内边距、边框
		offfsetWidth
			- 整个元素的宽度，包括内容区、内边距、边框
		offsetParent
			- 当前元素的定位父元素
			- 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body
		offsetLeft
		offsetTop
			- 当前元素和定位父元素之间的偏移量
			- offsetLeft水平偏移量  offsetTop垂直偏移量
		
		scrollHeight
		scrollWidth
			- 获取元素滚动区域的高度和宽度
		
		scrollTop
		scrollLeft
			- 获取元素垂直和水平滚动条滚动的距离
			
		判断滚动条是否滚动到底
			- 垂直滚动条
				scrollHeight - scrollTop = clientHeight
				
			- 水平滚动	
				scrollWidth - scrollLeft = clientWidth
44.事件（Event）
	- 事件对象
	- 当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，
		这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。
	- 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存
		- 例子：
			元素.事件 = function(event){
				event = event || window.event;   这个window需要带 因为设置参数为event重复
				
			};
			
			元素.事件 = function(e){
				e = e || event;   就是event没错
				
			};
			
	- 事件的冒泡（Bubble）
	- 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。
	- 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消
	- 可以将事件对象的cancelBubble设置为true，即可取消冒泡
		- 例子：
				元素.事件 = function(event){
					event = event || window.event;
					event.cancelBubble = true;
				};
45.事件的绑定
	-使用 对象.事件 = 函数 的形式绑定响应函数，
			它只能同时为一个元素的一个事件绑定一个响应函数，
			不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的
	-addEventListener()
				  	- 通过这个方法也可以为元素绑定响应函数
				  - 参数：
				  		1.事件的字符串，不要on
				  		2.回调函数，当事件触发时该函数会被调用
				  		3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false
				  
				  使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，
				  	这样当事件被触发时，响应函数将会按照函数的绑定顺序执行
				  
				  这个方法不支持IE8及以下的浏览器
				  使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false
					 * 需要使用event来取消默认行为event.preventDefault();
					 * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错
					 */
					event.preventDefault && event.preventDefault();
	attachEvent()
				  	- 在IE8中可以使用attachEvent()来绑定事件
				  - 参数：
				  		1.事件的字符串，要on
				 		2.回调函数
				
				  - 这个方法也可以同时为一个事件绑定多个处理函数，
				  		不同的是它是后绑定先执行，执行顺序和addEventListener()相反
	function bind(obj , eventStr , callback){
				if(obj.addEventListener){
					//大部分浏览器兼容的方式
					obj.addEventListener(eventStr , callback , false);
				}else{
					/*
					 * this是谁由调用方式决定
					 * callback.call(obj)
					 */
					//IE8及以下
					obj.attachEvent("on"+eventStr , function(){
						//在匿名函数中调用回调函数
						callback.call(obj);
					});
				}
			}




46.事件的捕捉 obj.setCapture &&obj.setCapture(); 给obj开启捕获所有鼠标所按下的事件
47.滚轮事件  onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，
				 	但是火狐不支持该属性
				 
				  在火狐中需要使用 DOMMouseScroll 来绑定滚动事件
				  	注意该事件需要通过addEventListener()函数来绑定
		event.wheelDelta 可以获取鼠标滚轮滚动的方向
				向上滚 120   向下滚 -120
				wheelDelta这个值我们不看大小，只看正负
		
				wheelDelta这个属性火狐中不支持
					在火狐中使用event.detail来获取滚动的方向
					向上滚 -3  向下滚 3
		判断鼠标滚轮滚动的方向
					if(event.wheelDelta > 0 || event.detail < 0){
						
					}else{
						
					}
48.键盘事件   onkeydown
			- 按键被按下
			- 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发
			- 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快
						这种设计是为了防止误操作的发生。
		onkeyup
			- 按键被松开
				
				 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document
		可以通过keyCode来获取按键的编码
					  	通过它可以判断哪个按键被按下
					 除了keyCode，事件对象中还提供了几个属性
					 	altKey
					  	ctrlKey
					  	shiftKey
					 		- 这个三个用来判断alt ctrl 和 shift是否被按下
					 			如果按下则返回true，否则返回false
49.BOM
			 * 	- 浏览器对象模型
			 * 	- BOM可以使我们通过JS来操作浏览器
			 * 	- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作
			 * 	- BOM对象
			 * 		Window
			 * 			- 代表的是整个浏览器的窗口，同时window也是网页中的全局对象
			 * 		Navigator
			 * 			- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
			 * 		Location
			 * 			- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
			 * 		History
			 * 			- 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
			 * 				由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
			 * 				而且该操作只在当次访问时有效
			 * 		Screen
			 * 			- 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息
			 * 
			 * 
			 * 		这些BOM对象在浏览器中都是作为window对象的属性保存的，
			 * 			可以通过window对象来使用，也可以直接使用
				如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息
			 * 比如：ActiveXObject
			 */
			/*if("ActiveXObject" in window){
				alert("你是IE，我已经抓住你了~~~");
			}else{
				alert("你不是IE~~~");
			}*/
		
	判断浏览器代码  var ua = navigator.userAgent;
			
			console.log(ua);
			
			if(/firefox/i.test(ua)){
				alert("你是火狐！！！");
			}else if(/chrome/i.test(ua)){
				alert("你是Chrome");
			}else if(/msie/i.test(ua)){
				alert("你是IE浏览器~~~");
			}else if("ActiveXObject" in window){
				alert("你是IE11，枪毙了你~~~");
			}
50.History
			 * 	- 对象可以用来操作浏览器向前或向后翻页
		-length
					 * 	- 属性，可以获取到当成访问的链接数量
		-back()
					 * 	- 可以用来回退到上一个页面，作用和浏览器的回退按钮一样
					 */
					//history.back();
		-forward()
					 * 	- 可以跳转下一个页面，作用和浏览器的前进按钮一样
					 */
					//history.forward();
		-go()
					 * 	- 可以用来跳转到指定的页面
					 * 	- 它需要一个整数作为参数
					 * 		1:表示向前跳转一个页面 相当于forward()
					 * 		2:表示向前跳转两个页面
					 * 		-1:表示向后跳转一个页面
					 * 		-2:表示向后跳转两个页面
					 */
					history.go(-2);
51.Location
			 * 	- 该对象中封装了浏览器的地址栏的信息
		-如果直接将location属性修改为一个完整的路径，或相对路径
					 * 	则我们页面会自动跳转到该路径，并且会生成相应的历史记录
					//location = "http://www.baidu.com";
					//location = "01.BOM.html";
					assign()
					 * 	- 用来跳转到其他的页面，作用和直接修改location一样
					//location.assign("http://www.baidu.com");
					reload()
					 * 	- 用于重新加载当前页面，作用和刷新按钮一样
					 * 	- 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面
					//location.reload(true);
					replace()
					 * 	- 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
					 * 		不会生成历史记录，不能使用回退按钮回退
					location.replace("01.BOM.html");
52.window
		-setInterval()
				 * 	- 定时调用
				 * 	- 可以将一个函数，每隔一段时间执行一次
				 * 	- 参数：
				 * 		1.回调函数，该函数会每隔一段时间被调用一次
				 * 		2.每次调用间隔的时间，单位是毫秒
				 * 
				 * 	- 返回值：
				 * 		返回一个Number类型的数据
				 * 		这个数字用来作为定时器的唯一标识
		-clearInterval()可以用来关闭一个定时器
				//方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
				可以接受任意参数，
				//clearInterval(timer);
		延时调用，
			 * 	延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次
			 * 
			 * 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次
			 * 
			 * 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择
		var timer = setTimeout(function(){
				console.log(num++);
			},3000);	
		//使用clearTimeout()来关闭一个延时调用
			clearTimeout(timer);
		






















