1.警告 alert(""); 
2.页面输出内容 document.write("");
3.向控制台输出console.log("");
4.变量赋值  var a=1243;
5.标识符规则 自主命名都可称标识符 
   规则： 1.含字母、数字、_、&
	  2.不能用数字开头
	  3.不能是ES中关键字或保留字
	  4.采用驼峰命名法
6.JS 中6种数据类型：
	String 	字符串    用""或者''不能混用   
			   \转移字符 \" 表示"   \'表示'  \n表示换行  \t表示制表符（相当于TAB键）  \\表示\		   		
	Number  数值      包括整数和浮点数（小数）
			  最大值Number.MAX_VALUE=1.7976931348623157e+308  超过最大值Infinity正无穷 -Infinity负无穷
			  最小是Number.MIN_VALUE=5e-324 无限接近0的最小数
			  NaN 是一个特殊的数值，表示Not A Number 
	Boolean 布尔值    只有2个  true 表示真  false表示假
	Null    空值      只有1个值就是null 专门用来表示空对象 用typeof检测类型反馈Object 
	Undefined 未定义  只有1个值就是undefined 用typeof检测返回undefined 定义过但是未赋值
	以上为基本数据类型

	下面为引用数据类型
	Object  对象
	Array: 特别的对象类型(下标/内部数据有序)
	Function: 特别的对象类型(可执行)

	- 判断
		typeof:
			可以区别: 数值, 字符串, 布尔值, undefined, function
			不能区别: null与对象, 一般对象与数组
		instanceof:
			专门用来判断对象数据的类型: Object, Array与Function
			- instanceof是如何判断的?
				* 表达式: A instanceof B
				* 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false
				* Function是通过new自己产生的实例
		===
			可以判断: undefined和null

	- undefined与null的区别?
		undefined代表没有赋值
		null代表赋值了, 只是值为null
	- 什么时候给变量赋值为null呢?
		var a = null //a将指向一个对象, 但对象此时还没有确定
		a = null //让a指向的对象成为垃圾对象

	
7.检查变量类型 语法： typeof 变量 列如：console.log(typeof a);
8.强制数据类型转换  
		1.将其他数据类型转换为String
		方法一：调用被转换数值类型的toString()方法 注：unll 和 undefined 这2个值没有toString方法
		方法二：调用String()函数 对于Number和Boolena其实就是调用toString()方法 对于null和undefined不会调用toString()方法 而是直接转换
		2.将其他数据类型装换为Number
		方法一：调用Number()函数 字符串--> 数字 1.纯数字字符串，直接转换为数字 2.含有非数字内容，转换为NaN 3.字符串是空串或者全是空格的字符串，转换为0
					 布尔-->数字 true 转换为1  false 转换为0
					 null-->数字  为0	
					 undefined-->数字 为NaN
		方法二：专门用来对付字符串
			parseInt() 把一个字符串转换为整数
			parseFloat() 把一个字符串转换为浮点数
			注:如果对非String使用以上 会先将其转换为String 然后在操作
		3.将其他数据类型转换为Boolean
			使用Boolean()函数 数字-->布尔 除了0和NaN其余全为true
					  字符串-->布尔 除了空串其余全为true
					  null和undefined转换为布尔为flase
					  对象转换为布尔为true 
9.其他的进制数字   在JS中，用0x开头表示16进制数字，如：0x10 输出为10进制16
			   用0开头表示8进制数字，如070 输出10进制56
		           用0b开头表示2进制数字（不是所有浏览器都支持），如0b10 输出10进制2
		   a=parseInt(a,10) 可以在parseInt（）中传递一个第二个参数，来指定数字的进制
10.运算符	typeof是一个运算符，可以获得一个值的类型，并将结果以字符串的形式返回
		算数运算符  除了加法 当对非Number类型的值进行运算时，会将值转换为Number然后在运算  注：任何值和NaN运算都得NaN
			+ 如果2个字符串进行加法运算，则会进行拼串，任何值和字符串相加，都会先转换为字符串，然后在拼串  可以给任意数据类型+""即可转换为String
			- 减法 *乘法 /除法  可以通过一个值-0 *1 /1来转换Number
			% 取模运算（取余数）
11.一元运算符 + 正号 不会对数字产生任何影响
	      - 负号 负号可以对数字进行负号取反
	      对于非Number的数据类型 会先转换成Number在运算。 对其他数据类型使用+将其装换为number
	      typeof 变量
12.自增和自减（课程17）  a++和++a 对于一个变量自增以后，原变量的值会立即自增1 但是a++的值为原变量的值（自增前的值） ++a的值为原变量的新值（自增后的值） 
13.逻辑运算符   !
			- 非运算可以对一个布尔值进行取反，true变false false边true
			- 当对非布尔值使用!时，会先将其转换为布尔值然后再取反
			- 我们可以利用!来将其他的数据类型转换为布尔值
		
		&&
			- &&可以对符号两侧的值进行与运算
			- 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。
			- 与是一个短路的与，如果第一个值是false，则不再检查第二个值
			- 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值
			- 规则：
					1.如果第一个值为false，则返回第一个值
					2.如果第一个值为true，则返回第二个值
		
		||
			- ||可以对符号两侧的值进行或运算
			- 只有两端都是false时，才会返回false。只要有一个true，就会返回true。
			- 或是一个短路的或，如果第一个值是true，则不再检查第二个值
			- 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值
			- 规则：	
					1.如果第一个值为true，则返回第一个值
					2.如果第一个值为false，则返回第二个值
14.赋值运算符
		= 
			- 可以将符号右侧的值赋值给左侧变量
			
		+=
			- a += 5 相当于 a = a+5
			- var str = "hello";  str += "world";
			
		-=
			- a -= 5  相当于 a = a-5
			
		*=
			- a *= 5 相当于 a = a*5
			
		/=
			- a /= 5 相当于 a = a/5	
	
		%=
			- a %= 5 相当于 a = a%5	
15.关系运算符
		- 关系运算符用来比较两个值之间的大小关系的
			>
			>=
			<
			<=
		- 关系运算符的规则和数学中一致，用来比较两个值之间的关系，
			如果关系成立则返回true，关系不成立则返回false。
		- 如果比较的两个值是非数值，会将其转换为Number然后再比较。
		- 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。  
16.utf-8编码如何使用   在script中 <script> \u四位编码(16进制)   </script>    在页面中<body> &#编码（10进制，需要转换用计算器）; </body>
17.相等运算符	==
			- 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false
			- 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，
				转换后相等它也会返回true
		!=
			- 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false
			- 不等也会做自动的类型转换。
			
		===
			- 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，
				如果两个值的类型不同，则直接返回false
				
		!==
			- 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true
			
		特殊的值：
			- null和undefined
				- 由于undefined衍生自null，所以null == undefined 会返回true。
					但是 null === undefined 会返回false。
					
			- NaN
				- NaN不与任何值相等，包括它自身 NaN == NaN //false
				
			- 判断一个值是否是NaN
				- 使用isNaN()函数
18.三元运算符：?:
			- 语法：条件表达式?语句1:语句2;
			- 执行流程：
				先对条件表达式求值判断，
					如果判断结果为true，则执行语句1，并返回执行结果
					如果判断结果为false，则执行语句2，并返回执行结果
19.流程控制语句
	- 程序都是自上向下的顺序执行的，
		通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。
	- 分类：
		1.条件判断语句
		2.条件分支语句
		3.循环语句
		
	条件判断语句
		- 条件判断语句也称为if语句
		- 语法一：
			if(条件表达式){
				语句...
			}
			
			- 执行流程：
				if语句执行时，会先对条件表达式进行求值判断，
					如果值为true，则执行if后的语句
					如果值为false，则不执行
		- 语法二：
			if(条件表达式){
				语句...
			}else{
				语句... 
			}
			
			- 执行流程：
				if...else语句执行时，会对条件表达式进行求值判断，
					如果值为true，则执行if后的语句
					如果值为false，则执行else后的语句
			
		- 语法三：
			if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else{
				语句...
			}
			
			- 执行流程
				- if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断，
					如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。
					如果判断结果为false，则继续向下判断，直到找到为true的为止。
					如果所有的条件表达式都是false，则执行else后的语句
20.条件分支语句
	- switch语句
	- 语法:
		switch(条件表达式){
			case 表达式:
				语句...
				break;
			case 表达式:
				语句...
				break;
			case 表达式:
				语句...
				break;
			default:
				语句...
				break;
		}
		
	- 执行流程：
		- switch...case...语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较，
			如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。
			如果所有的case判断结果都为false，则从default处开始执行代码。
21.循环语句
	- 通过循环语句可以反复执行某些语句多次
	- while循环
		- 语法：
			while(条件表达式){
				语句...
			}
			
		- 执行流程：
			while语句在执行时，会先对条件表达式进行求值判断，
				如果判断结果为false，则终止循环
				如果判断结果为true，则执行循环体
				循环体执行完毕，继续对条件表达式进行求值判断，依此类推
				
	- do...while循环
		- 语法:
			do{
				语句...
			}while(条件表达式)
			
		- 执行流程
			do...while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断，
				如果判断判断结果为false，则终止循环。
				如果判断结果为true，则继续执行循环体，依此类推
				
		- 和while的区别：
			while：先判断后执行
			do...while: 先执行后判断
			- do...while可以确保循环体至少执行一次。
			
			
	- for循环
		- 语法：
			for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){
				③语句...
			}
		- 执行流程：
			首先执行①初始化表达式，初始化一个变量，
			然后对②条件表达式进行求值判断，如果为false则终止循环
			如果判断结果为true，则执行③循环体
			循环体执行完毕，执行④更新表达式，对变量进行更新。
			更新表达式执行完毕重复②
			
	- 死循环
		while(true){
		
		}
		
		for(;;){
		
		}
提升性能:
	break 可以退出switch语句或循环语句,不能在if语句中使用break和continue,终止距离最近的循环语句
	label:循环语句  然后在break label;可以结束想要的循环
	continue跳过当次循环
	开方Math.sqrt()



22.总结类型转换 1.转换为String a.调用被转换函数类型的tostring（）方法
			       b.string()函数
			       c.+""加空串	       
		2.转换为Number a.Number（）函数
			       b.parseInt()  和parseFloat()
			       c.-0 *1 /1
			       d.+    直接前面添加一元运算符
		3.转换为Boolean a.Boolean()函数
				b.! !  
23.开启计时器测量时间 console.time("计时器的名字") 需要一个字符串作参数，用字符串给计时器进行表示 结束用console.timeEnd("")
24.对象（Object）
	- 对象是JS中的引用数据类型
	- 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性
	- 使用typeof检查一个对象时，会返回object
	对象的分类：1.内建对象：由ES标准中定义的对象，在ES实现中都可以使用，如：Math String Number Function.....
		    2.宿主对象：在JS运行环境提供的对象，目前主要讲由浏览器提供的对象.如BOM组 DOM组。
		    3.自定义对象：由开发人员自己创建的对象。
25.     - 创建对象
		- 方式一：
			- var obj = new Object();
		- 方式二：
			- var obj = {};
			
	- 向对象中添加属性
		- 语法：
			对象.属性名 = 属性值;
			对象["属性名"] = 属性值;
			
			- 对象的属性名没有任何要求，不需要遵守标识符的规范，
				但是在开发中，尽量按照标识符的要求去写。
			- 属性值也可以任意的数据类型。

	- 读取对象中的属性
		- 语法：
			对象.属性名
			对象["属性名"]
		- 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined
		
	- 删除对象中的属性
		- 语法：
			delete 对象.属性名
			delete 对象["属性名"]
	- 使用in检查对象中是否含有指定属性
		- 语法："属性名" in 对象
			- 如果在对象中含有该属性，则返回true
				如果没有则返回false
	- 使用对象字面量，在创建对象时直接向对象中添加属性
		语法：
			var obj = {
							属性名:属性值,
							属性名:属性值,
							属性名:属性值,
							属性名:属性值
					}
					
	- 基本数据类型和引用数据类型
		- 基本数据类型
			String Number Boolean Null Undefined
		- 引用数据类型
			Object
		- 基本数据类型的数据，变量是直接保存的它的值。
			变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。
		- 引用数据类型的数据，变量是保存的对象的引用（内存地址）。
			如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。
		- 比较两个变量时，对于基本数据类型，比较的就是值，
			对于引用数据类型比较的是地址，地址相同才相同

26.函数（Function）	
	- 函数也是一个对象，也具有普通对象的功能
	- 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码
	- 使用typeof检查一个函数时会返回function
	- 创建函数
		- 函数声明
			function 函数名([形参1,形参2...形参N]){
				语句...
			}
		
		- 函数表达式
			var 函数名 = function([形参1,形参2...形参N]){
				语句...
			};
			
	- 调用函数
		- 语法：函数对象([实参1,实参2...实参N]);
			fun() sum() alert() Number() parseInt()
		- 当我们调用函数时，函数中封装的代码会按照编写的顺序执行
		
		- call()
		- apply()
		- 这两个方法都是函数对象的方法需要通过函数对象来调用
		- 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this
		- 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递

	- 形参和实参
		- 形参：形式参数
			- 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开
				定义形参就相当于在函数内声明了对应的变量但是并不赋值，
				形参会在调用时才赋值。
				
		- 实参：实际参数
			- 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,
				调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。
				如果实参的数量大于形参，多余实参将不会赋值，
				如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined
	
	- arguments
		- arguments和this类似，都是函数中的隐含的参数
		- arguments是一个类数组元素，它用来封装函数执行过程中的实参
			所以即使不定义形参，也可以通过arguments来使用实参
		- arguments中有一个属性callee表示当前执行的函数对象
	
27.
	- 返回值，就是函数执行的结果。
		- 使用return 来设置函数的返回值。
		- 语法：return 值;
			- 该值就会成为函数的返回值，可以通过一个变量来接收返回值
		- return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。
		- return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。
		- 如果return后不跟值，或者是不写return则函数默认返回undefined。
		- break、continue和return
			- break
				- 退出循环
			- continue
				- 跳过当次循环
			- return
				- 退出函数
				
	- 参数，函数的实参也可以是任意的数据类型（对象，函数）。

	- 方法（method）
		- 可以将一个函数设置为一个对象的属性，
			当一个对象的属性是一个函数时，
				我们称这个函数是该对象的方法。
		- 对象.方法名();
		- 函数名();
28.枚举对象中的属性 使用for ... in 语句  对象中有几个属性，循环体就会执行几次 每次执行时，会将对象中的一个属性的名字赋值给变量
	列如：for（var n in obj）{
		 console.log(n);		   obj是对象
	      }
29.作用域
	- 作用域简单来说就是一个变量的作用范围。
	- 在JS中作用域分成两种：
		1.全局作用域
			- 直接在script标签中编写的代码都运行在全局作用域中
			- 全局作用域在打开页面时创建，在页面关闭时销毁。
			- 全局作用域中有一个全局对象window，window对象由浏览器提供，
				可以在页面中直接使用，它代表的是整个的浏览器的窗口。
			- 在全局作用域中创建的变量都会作为window对象的属性保存
				在全局作用域中创建的函数都会作为window对象的方法保存
			- 在全局作用域中创建的变量和函数可以在页面的任意位置访问。
				在函数作用域中也可以访问到全局作用域的变量。
			- 尽量不要在全局中创建变量	
		2.函数作用域
			- 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。
			- 函数作用域在函数执行时创建，在函数执行结束时销毁。
			- 在函数作用域中创建的变量，不能在全局中访问。
			- 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，
				如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，
					如果找到了则使用，找不到则继续向上找，一直会
					
		- 变量的声明提前
			- 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。
				所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。
			- 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，
				如果没有使用var关键字声明变量，则变量会变成全局变量
				
		- 函数的声明提前
			- 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，
				也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性
			- 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。
30.  this（上下文对象）	
	- 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。
		使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。
	- this的不同的情况：
		1.以函数的形式调用时，this是window
		2.以方法的形式调用时，this就是调用方法的对象
		3.以构造函数的形式调用时，this就是新创建的对象
		4.使用call和apply调用时，this是指定的那个对象
		5.在全局作用域中this代表window
31.使用工厂的方法创建对象 详细请看课程63
32.构造函数
	- 构造函数是专门用来创建对象的函数
	- 一个构造函数我们也可以称为一个类
	- 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例
	- 通过同一个构造函数创建的对象，我们称为一类对象
	- 构造函数就是一个普通的函数，只是他的调用方式不同，
		如果直接调用，它就是一个普通函数
		如果使用new来调用，则它就是一个构造函数
		
	- 例子：
		function Person(){
		
		}
		
	- 构造函数的执行流程：
		1.创建一个新的对象
		2.将新的对象作为函数的上下文对象（this）
		3.执行函数中的代码
		4.将新建的对象返回
		
	- instanceof 用来检查一个对象是否是一个类的实例
		- 语法：对象 instanceof 构造函数
			- 如果该对象时构造函数的实例，则返回true，否则返回false
			- Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true
			
	- 枚举对象中的属性
		for...in
		语法：
			for(var 属性名 in 对象){
			
			}
			
		for...in语句的循环体会执行多次，对象中有几个属性就会执行几次，
			每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性
33.原型（prototype）
	- 创建一个函数以后，解析器都会默认在函数中添加一个数prototype
		prototype属性指向的是一个对象，这个对象我们称为原型对象。
	- 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。
		这个隐含的属性可以通过  对象.__proto__  来访问。

	- 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。
		我们可以将对象中共有的属性和方法统一添加到原型对象中，
			这样我们只需要添加一次，就可以使所有的对象都可以使用。
	- 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，
		如果在自身中找到了，则直接使用。
		如果没有找到，则去原型对象中寻找，如果找到了则使用，
		如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null，
		如果依然没有找到则返回undefined
	- hasOwnProperty()
		- 这个方法可以用来检查对象自身中是否含有某个属性
		- 语法：对象.hasOwnProperty("属性名")
34.垃圾回收  将不在使用的对象设置为null  obj=null;
35.数组（Array）
	- 数组也是一个对象，是一个用来存储数据的对象
		和Object类似，但是它的存储效率比普通对象要高
	- 数组中保存的内容我们称为元素	
	- 数组使用索引（index）来操作元素
	- 索引指由0开始的整数
	-检查一个对象是不是数组 Array.isArray();  ()中填写要检查的对象
	- 数组的操作：
		- 创建数组
			- var arr = new Array();
			- var arr = [];
			
		- 向数组中添加元素
			- 语法；
				数组对象[索引] = 值;
				arr[0] = 123;
				arr[1] = "hello";
				
		- 创建数组时直接添加元素
			- 语法：
				var arr = [元素1,元素2....元素N];
				- 例子：
					var arr = [123,"hello",true,null];
					
		- 获取和修改数组的长度
			- 使用length属性来操作数组的长度
			- 获取长度：
				数组.length
				- length获取到的是数组的最大索引+1
				- 对于连续的数组，length获取到的就是数组中元素的个数
			- 修改数组的长度
				数组.length = 新长度
					- 如果修改后的length大于原长度，则多出的部分会空出来
					- 如果修改后的length小于原长度，则原数组中多出的元素会被删除
			- 向数组的最后添加元素
				数组[数组.length] = 值; 
		- 数组的方法
		- push()
			- 用来向数组的末尾添加一个或多个元素，并返回数组新的长度
			- 语法：数组.push(元素1,元素2,元素N)
		- pop()
			- 用来删除数组的最后一个元素，并返回被删除的元素
		- unshift()
			- 向数组的前边添加一个或多个元素，并返回数组的新的长度
		- shift()
			- 删除数组的前边的一个元素，并返回被删除的元素
		- slice()
			- 可以从一个数组中截取指定的元素
			- 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回
			- 参数：
				1.截取开始位置的索引（包括开始位置）
				2.截取结束位置的索引（不包括结束位置）
					- 第二个参数可以省略不写，如果不写则一直截取到最后
				- 参数可以传递一个负值，如果是负值，则从后往前数
		- splice()
			- 可以用来删除数组中指定元素，并使用新的元素替换
				该方法会将删除的元素封装到新数组中返回
			- 参数：
				1.删除开始位置的索引
				2.删除的个数
				3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边
		- reverse()
		- 可以用来反转一个数组，它会对原数组产生影响
		- concat()
		- 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回
		- join()
		- 可以将一个数组转换为一个字符串
		- 参数：
			需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素
			如果不指定连接符则默认使用,
		- sort()
		- 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序
			调用以后，会直接修改原数组。
		- 可以自己指定排序的规则，需要一个回调函数作为参数：
			function(a,b){
				
				//升序排列
				//return a-b;
				
				//降序排列
				return b-a;
			}
		- 遍历数组
		- 遍历数组就是将数组中元素都获取到
		- 一般情况我们都是使用for循环来遍历数组：
			for(var i=0 ; i<数组.length ; i++){
				//数组[i]
			}
			
		- 使用forEach()方法来遍历数组（不兼容IE8）
		
			数组.forEach(function(value , index , obj){
			
			});
			
			forEach()方法需要一个回调函数作为参数，
				数组中有几个元素，回调函数就会被调用几次，
				每次调用时，都会将遍历到的信息以实参的形式传递进来，
				我们可以定义形参来获取这些信息。
				value:正在遍历的元素
				index:正在遍历元素的索引
				obj:被遍历对象
36.Date
	- 日期的对象，在JS中通过Date对象来表示一个时间
	- 创建对象
		- 创建一个当前的时间对象
			var d = new Date();
		- 创建一个指定的时间对象
			var d = new Date("月/日/年 时:分:秒");
			
	- 方法：
		getDate()
			- 当前日期对象是几日（1-31）
			
		getDay() 
			- 返回当前日期对象时周几（0-6）
				- 0 周日
				- 1 周一 。。。
				
		getMonth()
			- 返回当前日期对象的月份（0-11）
			- 0 一月 1 二月 。。。
		getFullYear() 从 Date 对象以四位数字返回年份。 
		
		getHours() 返回 Date 对象的小时 (0 ~ 23)。 
		getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 
		getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 
		getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 
		
		getTime()
			- 返回当前日期对象的时间戳
			- 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数
				计算机底层保存时间都是以时间戳的形式保存的。
				
		Date.now()
			- 可以获取当前代码执行时的时间戳
37.Math			
	- Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法
		我们可以直接使用它来进行数学运算相关的操作
	- 方法：
		Math.PI
			- 常量，圆周率
		Math.abs()
			- 绝对值运算
		Math.ceil()
			- 向上取整
		Math.floor()
			- 向下取整
		Math.round()
			- 四舍五入取整
		Math.random()	
			- 生成一个0-1之间的随机数
			- 生成一个x-y之间的随机数
				Math.round(Math.random()*(y-x)+x);
		Math.pow(x,y)
			- 求x的y次幂
		Math.sqrt()
			- 对一个数进行开方
		Math.max()
			- 求多个数中最大值
		Math.min()
			- 求多个数中的最小值
38.包装类		
	- 在JS中为我们提供了三个包装类：
		String() Boolean() Number()
		- 通过这三个包装类可以创建基本数据类型的对象
		例子：
			var num = new Number(2);
			var str = new String("hello");
			var bool = new Boolean(true);
		- 但是在实际应用中千万不要这么干。
	
	- 当我们去操作一个基本数据类型的属性和方法时，
		解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，
		操作完成以后再将这个临时对象进行销毁。
39.字符串的相关的方法
	length
		- 获取字符串的长度
	charAt()
		- 根据索引获取指定的字符
	charCodeAt()
		- 根据索引获取指定的字符编码
	String.fromCharCode()
		- 根据字符编码获取字符
	indexOf()
	lastIndexOf()
		- 从一个字符串中检索指定内容
		- 需要一个字符串作为参数，这个字符串就是要检索的内容，
			如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。
		- 可以指定一个第二个参数，来表示开始查找的位置
		- indexOf()是从前向后找
		- lastIndexOf()是从后向前找
	slice()
		- 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量
		- 参数：
			第一个：截取开始的位置（包括开始）
			第二个：截取结束的位置（不包括结束）
				- 可以省略第二个参数，如果省略则一直截取到最后
			- 可以传负数，如果是负数则从后往前数
	substr()	
		- 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量
		
	substring()
		- 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，
			substring()中如果第二个参数小于第一个，自动调整位置
	toLowerCase() 
		- 将字符串转换为小写并返回
	toUpperCase() 
		- 将字符串转换为大写并返回
	split()
		- 可以根据指定内容将一个字符串拆分为一个数组
		- 参数：
			- 需要一个字符串作为参数，将会根据字符串去拆分数组
				可以接收一个正则表达式，此时会根据正则表达式去拆分数组
				
	match() 
		- 可以将字符串中和正则表达式匹配的内容提取出来
		- 参数：
			- 正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来
					并且封装到一个数组中返回
	
	replace()  
		- 可以将字符串中指定内容替换为新的内容
		- 参数：
			- 第一个：被替换的内容，可以是一个正则表达式
			- 第二个：替换的新内容
			
	search() 
		- 可以根据正则表达式去字符串中查找指定的内容
		- 参数：
			正则表达式，将会根据该表达式查询内容，
					并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1。
40.正则表达式 RegExp
	- 正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，
		也可以将一个字符串中符合规则的内容提取出来。
	- 创建正则表达式
		- var reg = new RegExp("正则","匹配模式");
		- var reg = /正则表达式/匹配模式
		
	- 语法：
		匹配模式：
			i:忽略大小写
			g:全局匹配模式
			- 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求
			
		正则语法		
			| 或
			[] 或
			[^ ] 除了
			[a-z] 小写字母
			[A-Z] 大写字母
			[A-z] 任意字母
			[0-9] 任意数字
		- 量词
			{n} 正好n次
			{m,n} m-n次
			{m,} 至少m次
			+	至少1次 {1,}
			?   0次或1次 {0,1}
			*   0次或多次 {0,}

			
		- 转义字符
			\ 在正则表达式中使用\作为转义字符
			\. 表示.
			\\ 表示\
			. 表示任意字符
			\w	  字母 数字 _
				- 相当于[A-z0-9_]
			\W	  除了字母 数字 _
				- 相当于[^A-z0-9_]
			\d        任意数字
				- 相当于[0-9]
			\D	  除了数字
				- 相当于[^0-9]
			\s
				- 空格
			\S
				- 除了空格
			\b
				- 单词边界
			\B
				- 除了单词边界
		^ 表示开始
		$ 表示结束
			
	- 方法：
		test()
			- 可以用来检查一个字符串是否符合正则表达式
			- 如果符合返回true，否则返回false
		-练习相关：1.例如：手机号正则表达式 var phoneReg=/^1[3-9][0-9]{9}$/
			   2.去除开头和结尾的全部空格 str.replace(/^\s*|\s*$/g,"");
			   3.邮件格式  var emailReg=/^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/;
41.DOM
	- Document Object Model
	- 文档对象模型，通过DOM可以来任意来修改网页中各个内容
	- 文档
		- 文档指的是网页，一个网页就是一个文档
	- 对象
		- 对象指将网页中的每一个节点都转换为对象
			转换完对象以后，就可以以一种纯面向对象的形式来操作网页了
	- 模型
		- 模型用来表示节点和节点之间的关系，方便操作页面
	- 节点（Node）
		- 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点
		- 虽然都是节点，但是节点的类型却是不同的
		- 常用的节点
			- 文档节点 （Document），代表整个网页
			- 元素节点（Element），代表网页中的标签
			- 属性节点（Attribute），代表标签中的属性
			- 文本节点（Text），代表网页中的文本内容
			
	- DOM操作
		- DOM查询
		- 在网页中浏览器已经为我们提供了document对象，
			它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。
		- document查询方法：
			- 根据元素的id属性查询一个元素节点对象：
				- document.getElementById("id属性值");
			- 根据元素的name属性值查询一组元素节点对象:
				- document.getElementsByName("name属性值");
			- 根据标签名来查询一组元素节点对象：
				- document.getElementsByTagName("标签名");
				
		- 元素的属性：
			- 读取元素的属性：
				语法：元素.属性名
				例子：ele.name  
					  ele.id  
					  ele.value 
					  ele.className
					  
			- 修改元素的属性：
				语法：元素.属性名 = 属性值
				
			- innerHTML
				- 使用该属性可以获取或设置元素内部的HTML代码
				
				
	- 事件（Event）
		- 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。
		- 我们可以为事件来绑定回调函数来响应事件。
		- 绑定事件的方式：
			1.可以在标签的事件属性中设置相应的JS代码
				例子：
					<button onclick="js代码。。。">按钮</button>
			2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件
				例子：
					<button id="btn">按钮</button>
					<script>
						var btn = document.getElementById("btn");
						btn.onclick = function(){
						
						};
					</script>
					
	- 文档的加载
		- 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。
		- 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，
			此时将会无法正常获取到DOM对象，导致DOM操作失败。
		- 解决方式一：
			- 可以将js代码编写到body的下边
			<body>
				<button id="btn">按钮</button>
				<script>
					var btn = document.getElementById("btn");
					btn.onclick = function(){
					
					};
				</script>
			</body>
			
		- 解决方式二：
			- 将js代码编写到window.onload = function(){}中
			- window.onload 对应的回调函数会在整个页面加载完毕以后才执行，
				所以可以确保代码执行时，DOM对象已经加载完毕了
			<script>
				window.onload = function(){
					var btn = document.getElementById("btn");
					btn.onclick = function(){
					
					};
				};
			
			</script>	
42.DOM查询
	- 通过具体的元素节点来查询
		- 元素.getElementsByTagName()
			- 通过标签名查询当前元素的指定后代元素
			
		- 元素.childNodes
			- 获取当前元素的所有子节点
			- 会获取到空白的文本子节点
		
		- 元素.children
			- 获取当前元素的所有子元素
		
		- 元素.firstChild
			- 获取当前元素的第一个子节点
		
		- 元素.lastChild
			- 获取当前元素的最后一个子节点
		
		- 元素.parentNode
			- 获取当前元素的父元素
		
		- 元素.previousSibling
			- 获取当前元素的前一个兄弟节点
		
		- 元素.nextSibling
			- 获取当前元素的后一个兄弟节点
	- document对象的其他的属性和方法
		document.all
			- 获取页面中的所有元素，相当于document.getElementsByTagName("*");
			
		document.documentElement
			- 获取页面中html根元素
			
		document.body
			- 获取页面中的body元素
			
		document.getElementsByClassName("")
			- 根据元素的class属性值查询一组元素节点对象
			- 这个方法不支持IE8及以下的浏览器
			
		document.querySelector("")
			- 根据CSS选择器去页面中查询一个元素
			- 如果匹配到的元素有多个，则它会返回查询到的第一个元素	
			
		document.querySelectorAll("")	例如 var div=document.querySelectorAll(".box1 div")
			- 根据CSS选择器去页面中查询一组元素
			- 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个
			
	innerHTML和innerText
		- 这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性
		- 两个属性作用类似，都可以获取到标签内部的内容，
			不同是innerHTML会获取到html标签，而innerText会自动去除标签
		- 如果使用这两个属性来设置标签内部的内容时，没有任何区别的	
		
	读取标签内部的文本内容
		<h1>h1中的文本内容</h1>
		元素.firstChild.nodeValue

		DOM修改
	document.createElement()
		- 可以根据标签名创建一个元素节点对象
		
	document.createTextNode()
		- 可以根据文本内容创建一个文本节点对象
		
	父节点.appendChild(子节点)
		- 向父节点中添加指定的子节点
		
	父节点.insertBefore(新节点,旧节点)
		- 将一个新的节点插入到旧节点的前边
		
	父节点.replaceChild(新节点,旧节点)
		- 使用一个新的节点去替换旧节点
		
	父节点.removeChild(子节点)
		- 删除指定的子节点
		- 推荐方式：子节点.parentNode.removeChild(子节点)
43.DOM对CSS的操作
	- 读取和修改内联样式
		- 使用style属性来操作元素的内联样式
		- 读取内联样式：  只能读取内联样式，不能读取style中的样式（当前样式）
			语法：元素.style.样式名
			- 例子：
				元素.style.width
				元素.style.height
				- 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法
					将-去掉，然后-后的字母改大写
				- 比如：background-color --> backgroundColor
						border-width ---> borderWidth
						
		- 修改内联样式：
			语法：元素.style.样式名 = 样式值
			- 通过style修改的样式都是内联样式，由于内联样式的优先级比较高，
				所以我们通过JS来修改的样式，往往会立即生效，
				但是如果样式中设置了!important，则内联样式将不会生效。
				
	- 读取元素的当前样式   课程109课  不仅仅可以读取当前样式
		- 正常浏览器
			- 使用getComputedStyle()
			- 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式
			- 参数：
				1.要获取样式的元素
				2.可以传递一个伪元素，一般传null
			- 例子：
				获取元素的宽度
					getComputedStyle(box , null)["width"];
			- 通过该方法读取到样式都是只读的不能修改

		- IE8
			- 使用currentStyle
			- 语法：
				元素.currentStyle.样式名
			- 例子：
				box.currentStyle["width"]
			- 通过这个属性读取到的样式是只读的不能修改
		-综合自写的查看样式的代码
		function getStyle(obj , name){
				
				if(window.getComputedStyle){
					//正常浏览器的方式，具有getComputedStyle()方法
					return getComputedStyle(obj , null)[name];
				}else{
					//IE8的方式，没有getComputedStyle()方法  注意：IE中如果没有设置属性会返回auto 可以设置属性为0
					return obj.currentStyle[name];
				}
				
				
				
			}




		- 其他的样式相关的属性
		注意：以下样式都是只读的
	
		clientHeight
			- 元素的可见高度，指元素的内容区和内边距的高度
		clientWidth
			- 元素的可见宽度，指元素的内容区和内边距的宽度
		offsetHeight
			- 整个元素的高度，包括内容区、内边距、边框
		offfsetWidth
			- 整个元素的宽度，包括内容区、内边距、边框
		offsetParent
			- 当前元素的定位父元素
			- 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body
		offsetLeft
		offsetTop
			- 当前元素和定位父元素之间的偏移量
			- offsetLeft水平偏移量  offsetTop垂直偏移量
		
		scrollHeight
		scrollWidth
			- 获取元素滚动区域的高度和宽度
		
		scrollTop
		scrollLeft
			- 获取元素垂直和水平滚动条滚动的距离
			
		判断滚动条是否滚动到底
			- 垂直滚动条
				scrollHeight - scrollTop = clientHeight
				
			- 水平滚动	
				scrollWidth - scrollLeft = clientWidth
44.事件（Event）
	- 事件对象
	- 当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，
		这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。
	- 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存
		- 例子：
			元素.事件 = function(event){
				event = event || window.event;   这个window需要带 因为设置参数为event重复
				
			};
			
			元素.事件 = function(e){
				e = e || event;   就是event没错
				
			};
			
	- 事件的冒泡（Bubble）
	- 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。
	- 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消
	- 可以将事件对象的cancelBubble设置为true，即可取消冒泡
		- 例子：
				元素.事件 = function(event){
					event = event || window.event;
					event.cancelBubble = true;
				};
45.事件的绑定
	-使用 对象.事件 = 函数 的形式绑定响应函数，
			它只能同时为一个元素的一个事件绑定一个响应函数，
			不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的
	-addEventListener()
				  	- 通过这个方法也可以为元素绑定响应函数
				  - 参数：
				  		1.事件的字符串，不要on
				  		2.回调函数，当事件触发时该函数会被调用
				  		3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false
				  
				  使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，
				  	这样当事件被触发时，响应函数将会按照函数的绑定顺序执行
				  
				  这个方法不支持IE8及以下的浏览器
				  使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false
					 * 需要使用event来取消默认行为event.preventDefault();
					 * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错
					 */
					event.preventDefault && event.preventDefault();
	attachEvent()
				  	- 在IE8中可以使用attachEvent()来绑定事件
				  - 参数：
				  		1.事件的字符串，要on
				 		2.回调函数
				
				  - 这个方法也可以同时为一个事件绑定多个处理函数，
				  		不同的是它是后绑定先执行，执行顺序和addEventListener()相反
	function bind(obj , eventStr , callback){
				if(obj.addEventListener){
					//大部分浏览器兼容的方式
					obj.addEventListener(eventStr , callback , false);
				}else{
					/*
					 * this是谁由调用方式决定
					 * callback.call(obj)
					 */
					//IE8及以下
					obj.attachEvent("on"+eventStr , function(){
						//在匿名函数中调用回调函数
						callback.call(obj);
					});
				}
			}




46.事件的捕捉 obj.setCapture &&obj.setCapture(); 给obj开启捕获所有鼠标所按下的事件
47.滚轮事件  onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，
				 	但是火狐不支持该属性
				 
				  在火狐中需要使用 DOMMouseScroll 来绑定滚动事件
				  	注意该事件需要通过addEventListener()函数来绑定
		event.wheelDelta 可以获取鼠标滚轮滚动的方向
				向上滚 120   向下滚 -120
				wheelDelta这个值我们不看大小，只看正负
		
				wheelDelta这个属性火狐中不支持
					在火狐中使用event.detail来获取滚动的方向
					向上滚 -3  向下滚 3
		判断鼠标滚轮滚动的方向
					if(event.wheelDelta > 0 || event.detail < 0){
						
					}else{
						
					}
48.键盘事件   onkeydown
			- 按键被按下
			- 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发
			- 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快
						这种设计是为了防止误操作的发生。
		onkeyup
			- 按键被松开
				
				 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document
		可以通过keyCode来获取按键的编码
					  	通过它可以判断哪个按键被按下
					 除了keyCode，事件对象中还提供了几个属性
					 	altKey
					  	ctrlKey
					  	shiftKey
					 		- 这个三个用来判断alt ctrl 和 shift是否被按下
					 			如果按下则返回true，否则返回false
49.BOM
			 * 	- 浏览器对象模型
			 * 	- BOM可以使我们通过JS来操作浏览器
			 * 	- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作
			 * 	- BOM对象
			 * 		Window
			 * 			- 代表的是整个浏览器的窗口，同时window也是网页中的全局对象
			 * 		Navigator
			 * 			- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
			 * 		Location
			 * 			- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
			 * 		History
			 * 			- 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
			 * 				由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
			 * 				而且该操作只在当次访问时有效
			 * 		Screen
			 * 			- 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息
			 * 
			 * 
			 * 		这些BOM对象在浏览器中都是作为window对象的属性保存的，
			 * 			可以通过window对象来使用，也可以直接使用
				如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息
			 * 比如：ActiveXObject
			 */
			/*if("ActiveXObject" in window){
				alert("你是IE，我已经抓住你了~~~");
			}else{
				alert("你不是IE~~~");
			}*/
		
	判断浏览器代码  var ua = navigator.userAgent;
			
			console.log(ua);
			
			if(/firefox/i.test(ua)){
				alert("你是火狐！！！");
			}else if(/chrome/i.test(ua)){
				alert("你是Chrome");
			}else if(/msie/i.test(ua)){
				alert("你是IE浏览器~~~");
			}else if("ActiveXObject" in window){
				alert("你是IE11，枪毙了你~~~");
			}
50.History
			 * 	- 对象可以用来操作浏览器向前或向后翻页
		-length
					 * 	- 属性，可以获取到当成访问的链接数量
		-back()
					 * 	- 可以用来回退到上一个页面，作用和浏览器的回退按钮一样
					 */
					//history.back();
		-forward()
					 * 	- 可以跳转下一个页面，作用和浏览器的前进按钮一样
					 */
					//history.forward();
		-go()
					 * 	- 可以用来跳转到指定的页面
					 * 	- 它需要一个整数作为参数
					 * 		1:表示向前跳转一个页面 相当于forward()
					 * 		2:表示向前跳转两个页面
					 * 		-1:表示向后跳转一个页面
					 * 		-2:表示向后跳转两个页面
					 */
					history.go(-2);
51.Location
			 * 	- 该对象中封装了浏览器的地址栏的信息
		-如果直接将location属性修改为一个完整的路径，或相对路径
					 * 	则我们页面会自动跳转到该路径，并且会生成相应的历史记录
					//location = "http://www.baidu.com";
					//location = "01.BOM.html";
					assign()
					 * 	- 用来跳转到其他的页面，作用和直接修改location一样
					//location.assign("http://www.baidu.com");
					reload()
					 * 	- 用于重新加载当前页面，作用和刷新按钮一样
					 * 	- 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面
					//location.reload(true);
					replace()
					 * 	- 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
					 * 		不会生成历史记录，不能使用回退按钮回退
					location.replace("01.BOM.html");
52.window
		-setInterval()
				 * 	- 定时调用
				 * 	- 可以将一个函数，每隔一段时间执行一次
				 * 	- 参数：
				 * 		1.回调函数，该函数会每隔一段时间被调用一次
				 * 		2.每次调用间隔的时间，单位是毫秒
				 * 
				 * 	- 返回值：
				 * 		返回一个Number类型的数据
				 * 		这个数字用来作为定时器的唯一标识
		-clearInterval()可以用来关闭一个定时器
				//方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
				可以接受任意参数，
				//clearInterval(timer);
		延时调用，
			 * 	延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次
			 * 
			 * 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次
			 * 
			 * 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择
		var timer = setTimeout(function(){
				console.log(num++);
			},3000);	
		//使用clearTimeout()来关闭一个延时调用
			clearTimeout(timer);
53.JSON
			 * 	- JS中的对象只有JS自己认识，其他的语言都不认识
			 * 	- JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，
			 * 		并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互
			 * 	- JSON
			 * 		- JavaScript Object Notation JS对象表示法
			 * 		- JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号
			 * 			其他的和JS语法一致
			 * 		JSON分类：
			 * 			1.对象 {}
			 * 			2.数组 []
			 * 
			 * 		JSON中允许的值：
			 * 			1.字符串
			 * 			2.数值
			 * 			3.布尔值
			 * 			4.null
			 * 			5.对象
			 * 			6.数组
		将JSON字符串转换为JS中的对象
			 * 	在JS中，为我们提供了一个工具类，就叫JSON
			 * 	这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON

		var json = '{"name":"孙悟空","age":18,"gender":"男"}';
			
			/*
			 * json --> js对象
			 * 	 JSON.parse()
			 * 		- 可以将以JSON字符串转换为js对象
			 * 		- 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回
			 */
			
			var o = JSON.parse(json);

		var obj3 = {name:"猪八戒" , age:28 , gender:"男"};
			
			
			/*
			 * JS对象 ---> JSON
			 * 	JSON.stringify()
			 * 		- 可以将一个JS对象转换为JSON字符串
			 * 		- 需要一个js对象作为参数，会返回一个JSON字符串
			 */
			
			var str = JSON.stringify(obj3);
		 	* JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错，可以引入一个外部js文件来解决
					
		

			







									js高级

一、数据-变量-内存
	1. 什么是数据?
		存储于内存中代表特定信息的'东东', 本质就是0101二进制
		具有可读和可传递的基本特性,万物(一切)皆数据, 函数也是数据
	2. 什么是内存?
		内存的空间是临时的, 而硬盘的空间是持久的
		一块内存包含2个数据:内部存储的数据(一般数据/地址数据);内存地址值数据
	3. 什么是变量?
		值可以变化的量, 由变量名与变量值组成
		一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容
	4. 内存,数据, 变量三者之间的关系
		内存是一个容器, 用来存储程序运行需要操作的数据
		变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据
	5. 在js调用函数时传递变量参数时, 是值传递还是引用传递
		* 只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据
		* 如果后一种看成是引用传递（地址值）, 那就值传递和引用传递都可以有
	6. JS引擎如何管理内存?
		- 内存生命周期
			1). 分配需要的内存
			2). 使用分配到的内存
			3). 不需要时将其释放/归还
		- 释放内存	
			* 为执行函数分配的栈空间内存: 函数执行完自动释放
			* 存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存	

二、关于引用变量赋值问题
	1.2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见
	例子：  var obj1 = {}
		var obj2 = obj1
		obj2.name = 'Tom'
		此时console.log(obj1.name) obj1.name也会输出'Tom'
	2.2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象
	例子 ： var obj3 = {name: 'Tom'}
		var obj4 = obj3
		obj3 = {name: 'JACK'}
		console.log(obj4.name) 此时obj3已经从新赋值对象，obj4.name 应该输出'Tom'
		function f2(obj) {
					obj = {name: 'Bob'}
				}
		f2(obj4);
		console.log(obj4.name) 
		注意：这个很容易错，结果obj4.name还是‘Tom’，这个函数，首先是把obj4的内容传给obj，然后obj又重新赋值了一个对象切断了与obj4之间的联系，并没有修改到原对象。

三、对象
	1. 什么是对象?
		* 代表现实中的某个事物, 是该事物在编程中的抽象
		* 多个数据的集合体(封装体)
		* 用于保存多个数据的容器
	2. 为什么要用对象?
		* 便于对多个数据进行统一管理
	3. 对象的组成
		- 属性
			* 代表现实事物的状态数据
			* 由属性名和属性值组成
			* 属性名都是字符串类型, 属性值是任意类型
		- 方法
			* 代表现实事物的行为数据
			* 是特别的属性==>属性值是函数
	4. 如何访问对象内部数据?
		* .属性名: 编码简单, 但有时不能用
		* ['属性名']: 编码麻烦, 但通用
		问题: 什么时候必须使用['属性名']的方式?
			* 属性名不是合法的标识名。例如:p['content-type'] = 'text/json'
			* 属性名不确定。例如:var prop = 'xxx'; var value = 123 ; p[prop] = value 注意[]没有引号表示变量

四、函数
	1. 什么是函数?
		* 具有特定功能的n条语句的封装体
		* 只有函数是可执行的, 其它类型的数据是不可执行的
		* 函数也是对象
	2. 为什么要用函数?
		* 提高代码复用
		* 便于阅读和交流
	3. 如何定义函数?
		* 函数声明
			function f1 () { // 函数声明
				console.log('f1()')
			}
		* 表达式
			var f2 = function () { // 表达式
				console.log('f2()')
			}
	4. 如何调用(执行)函数?
		* test()
		* new test()
		* obj.test()
		* test.call/apply(obj) 该方法很强大，可以把一个函数成为任意对象的方法进行调用
		举例：
		var obj={};
		function test2(){
			this.xxx="atguigu";
		}
		//obj.test2()不能直接调用，因为根本就没有
		test2.call(obj)      //相当于obj.test2()  可以让一个函数成为指定任意对象的方法进行调用
		console.log(obj.xxx) //验证如果输出atguigu，说明确实调用了
	5. 什么函数才是回调函数?
		* 你定义的
		* 你没有直接调用
		* 但最终它执行了(在特定条件或时刻)
	6. 常见的回调函数?
		* DOM事件函数 ==========>this是触发DOM事件的元素
		* 定时器函数============>this是window
		* ajax回调函数(后面学)
		* 生命周期回调函数(后面学)
	7. IIFE
		全称: Immediately-Invoked Function Expression 立即调用函数表达式
		别名: 匿名函数自调用
		作用:
			* 隐藏内部实现
			* 不污染外部命名空间
			例子：
			(function (i) {
				var a = 4
				function fn() {
					console.log('fn ', i+a)
				}
				fn()
			})(3)
			输出结果为：fn 7
	8.函数中的this
		- this是什么?
			* 一个关键字, 一个内置的引用变量
			* 在函数中都可以直接使用this
			* this代表调用函数的当前对象
			* 在定义函数时, this还没有确定, 只有在执行时才动态确定(绑定)的
		- 如何确定this的值?
			* 本质上任何函数在执行时都是通过某个对象调用的，如果没有指定就是window
			* test()          //this是window
			* obj.test()      //this是obj
			* new test()      //this是新创建的对象
			* test.call(obj)  //this是obj

五、分号问题
	1. js一条语句的后面可以不加分号
	2. 是否加分号是编码风格问题, 没有应该不应该，只有你自己喜欢不喜欢
	3. 在下面2种情况下不加分号会有问题
		* 小括号开头的前一条语句    //不加分号容易被理解为函数执行
		* 中方括号开头的前一条语句  //不加分号容易被理解为数组
	4. 解决办法: 在行首加分号
	5. 强有力的例子: vue.js库

六、原型(prototype)
	1. 函数的prototype属性
		* 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
		function fn() {}
		console.log(fn.prototype, typeof fn.prototype)
		* 原型对象中有一个属性constructor, 它指向函数对象
		console.log(fn.prototype.constructor===fn)  //true
	2. 给原型对象添加属性(一般都是方法)
		* 作用: 函数的所有实例对象自动拥有原型中的属性(方法)
		function F() {}
		F.prototype.setAge = function (age) { // 添加方法
			this.age = age
		}
		var f = new F()    // 创建函数的实例对象
		f.setAge(23)
		console.log(f.age) // 23
	3. 显式原型与隐式原型
		* 每个函数function都有一个prototype，即显式原型
		* 每个实例对象都有一个__proto__，可称为隐式原型
		* 对象的隐式原型的值为其对应构造函数的显式原型的值
			function Fn() {}
			var fn = new Fn()
			console.log(Fn.prototype===fn.__proto__)  //true
		* 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象
		* 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值
		* 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)
	4. 原型链(别名：隐式原型链)
		- 访问一个对象的属性时
			* 先在自身属性中查找，找到返回
			* 如果没有, 再沿着__proto__这条链向上查找, 找到返回
			* 如果最终没找到, 返回undefined
		- 作用: 查找对象的属性(方法)
		- 构造函数/原型/实体对象的关系(图解)
		- 特殊例子：
			a.函数的显式原型指向的对象默认是空Object实例对象（但Object不满足）
			function Fn() {}
			console.log(Fn.prototype instanceof Object)        //true
			console.log(Object.prototype instanceof Object)    //false
			console.log(Function.prototype instanceof Object)  //true
			b.所有函数都是Function的实例（包含Function本身）
			console.log(Function.__proto__ === Function.prototype) //true
			c.Object的原型对象是原型链的尽头
			console.log(Object.prototype.__proto__) //null
	5. 原型链_属性问题
		- 读取对象的属性值时: 会自动到原型链中查找
		- 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值
		- 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上

七、 变量提升与函数提升
	1. 变量声明提升
		* 通过var定义(声明)的变量, 在定义语句之前就可以访问到
		* 值: undefined
	2. 函数声明提升
		* 通过function声明的函数, 在之前就可以直接调用
		* 值: 函数定义(对象)
	注：先执行变量提升, 再执行函数提升

八、 执行上下文
	1. 代码分类(位置)
		* 全局代码
		* 函数代码
	2. 全局执行上下文
		- 在执行全局代码前将window确定为全局执行上下文
		- 对全局数据进行预处理
			* var定义的全局变量==>undefined, 添加为window的属性
			* function声明的全局函数==>赋值(fun), 添加为window的方法
			* this==>赋值(window)
		- 开始执行全局代码
	3. 函数执行上下文
		- 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象
		- 对局部数据进行预处理
			* 形参变量==>赋值(实参)==>添加为执行上下文的属性
			* arguments==>赋值(实参列表), 添加为执行上下文的属性
			* var定义的局部变量==>undefined, 添加为执行上下文的属性
			* function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
			* this==>赋值(调用函数的对象)
		- 开始执行函数体代码
	4. 函数执行上下文栈
		执行过程：
			* 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
			* 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
			* 在函数执行上下文创建后, 将其添加到栈中(压栈)
			* 在当前函数执行完后,将栈顶的对象移除(出栈)
			* 当所有的代码执行完后, 栈中只剩下window
		例子：
			<script type="text/javascript">
				console.log('gb: '+ i)
				var i = 1
				foo(1)
				function foo(i) {
					if (i == 4) {
						return
					}
					console.log('fb:' + i)
					foo(i + 1) //递归调用: 在函数内部调用自己
					console.log('fe:' + i)
				}
				console.log('ge: ' + i)
				</script>
			问题：1. 依次输出什么?
				gb: undefined
				fb: 1
				fb: 2
				fb: 3
				fe: 3
				fe: 2
				fe: 1
				ge: 1
				2. 整个过程中产生了几个执行上下文?  5
				n+1原则，n表示调用几次函数，1表示全局执行上下文
	5.经典面试题
		测试题1: * 先执行变量提升, 再执行函数提升
			function a() {}
			var a
			console.log(typeof a)  // 'function'
		测试题2:

			if (!(b in window)) {
				var b = 1
			}
			console.log(b)		// undefined
		测试题3:
			var c = 1
			function c(c) {
				console.log(c)
				var c = 3
			}
			c(2)			// 报错(因为最后赋值了c=1，所以c不是一个函数无法调用)

九、 作用域
	1. 理解
		* 就是一块"地盘", 一个代码段所在的区域
		* 它是静态的(相对于上下文对象), 在编写代码时就确定了
	2. 分类
		* 全局作用域
		* 函数作用域
		* 没有块作用域(ES6有了)
	3. 作用
		* 隔离变量，不同作用域下同名变量不会有冲突
	4. 作用于与执行上下文
		- 区别1
			* 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
			* 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
			* 函数执行上下文是在调用函数时, 函数体代码执行之前创建
		- 区别2
			* 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
			* 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放
		- 联系
			* 执行上下文(对象)是从属于所在的作用域
			* 全局上下文环境==>全局作用域
			* 函数上下文环境==>对应的函数使用域
	5. 作用域链
		- 理解
			* 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
			* 查找变量时就是沿着作用域链来查找的
			* 作用域的个数遵循n+1原则，n为定义多少个函数，1为全局作用域
		- 查找一个变量的查找规则
			* 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2
			* 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3
			* 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常
	6. 作用域_面试题
		- var x = 10;
		  function fn() {
			console.log(x);
		  }
		  function show(f) {
			var x = 20;
			f();
		  }
		  show(fn);
		输出结果为：10    （因为作用域是静态的，在调用之前就确定好了）
		- var fn = function () {
		  console.log(fn)
		  }
		  fn()
		输出结果为：function(){console.log(fn)}
		- var obj = {
			fn2: function () {
			console.log(fn2)
			//console.log(this.fn2)
			}
		  }
		  obj.fn2()
		输出结果为：报错(因为fn2首先在function下找，如果没有直接去全局找，都没有则报错，下面那种输出就可以找到)

十、 闭包
	1. 如何产生闭包?
		* 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包
		* 闭包产生的个数=外部函数被调用的次数
	2. 闭包到底是什么?
		* 使用chrome调试查看
		* 理解一: 闭包是嵌套的内部函数(绝大部分人)
		* 理解二: 包含被引用变量(函数)的对象(极少数人)
		* 注意: 闭包存在于嵌套的内部函数中
	3. 产生闭包的条件?
		* 函数嵌套
		* 内部函数引用了外部函数的数据(变量/函数)
	4. 常见的闭包
		- 将函数作为另一个函数的返回值
			例子1：
			function fn1() {
				var a = 2
				function fn2() {
					a++
					console.log(a)
				}
				return fn2
			}
			var f = fn1()
			f() // 3
			f() // 4
		- 将函数作为实参传递给另一个函数调用
			例子2：
			function showDelay(msg, time) {
				setTimeout(function () {
					alert(msg)
				}, time)
			}
			howDelay('atguigu', 2000)
	5. 闭包的作用(上例1)
		- 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
		- 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
		- 问题：
			* 函数执行完后, 函数内部声明的局部变量是否还存在?  一般是不存在, 存在于闭中的变量才可能存在
			* 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它
	6. 闭包的生命周期
		- 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
		- 死亡: 在嵌套的内部函数成为垃圾对象时
		- 例子：
			function fn1() {
				//此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)
				var a = 2
				function fn2 () {
					a++
					console.log(a)
				}
				return fn2
			}
			var f = fn1()
			f() // 3
			f() // 4
			f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)
	7. 闭包的应用：定义JS模块
		* 具有特定功能的js文件
		* 将所有的数据和功能都封装在一个函数内部(私有的)
		* 只向外暴露一个包信n个方法的对象或函数
		* 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
		- 定义js模块2种方法
			方法一：
			* js模块通过return {}返回
			* 使用的时候先引入
			* 然后的先执行var module=myModule()
			* 才能使用 module.doSomething()
			方法二：
			* js模块利用匿名函数自调用(function (w) {})(window)
			* 通过w.myModule2={}返回
			* 使用的时候先引入
			* 然后就能直接使用 module2.doSomething()
	8. 闭包的缺点及解决
		- 缺点：
			* 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
			* 容易造成内存泄露
		- 解决：
			* 能不用闭包就不用
			* 及时释放  f = null //让内部函数成为垃圾对象-->回收闭包

			
十一、 内存溢出与内存泄漏
	1. 内存溢出
		* 一种程序运行出现的错误
		* 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误
	2. 内存泄露
		* 占用的内存没有及时释放
		* 内存泄露积累多了就容易导致内存溢出
		* 常见的内存泄露:
			* 意外的全局变量
			function fn() {
				a = new Array(10000000)  //定义a的时候没有用var
				console.log(a)
			}
			fn()
			* 没有及时清理的计时器或回调函数
			var intervalId = setInterval(function () { //启动循环定时器后不清理
				console.log('----')
			}, 1000)
			// clearInterval(intervalId)  //没有这句关闭计时器，会一直运行
			* 闭包
			function fn1() {
				var a = 4
				function fn2() {
					console.log(++a)
				}
				return fn2
			}
			var f = fn1()
			f()

			// f = null   //没有这句f=null，由于f一直引用，所以不会成为垃圾对象，不会进行回收

十二、 对象的创造模式
	1. Object构造函数模式
		* 套路: 先创建空Object对象, 再动态添加属性/方法
		* 适用场景: 起始时不确定对象内部数据
		* 问题: 语句太多
		例子：
			var p = new Object() 或者 p = {} //此时内部数据是不确定的
			p.name = 'Tom'
			p.age = 12
			p.setName = function (name) {
				this.name = name
			}
	2. 对象字面量模式
		* 套路: 使用{}创建对象, 同时指定属性/方法
		* 适用场景: 起始时对象内部数据是确定的
		* 问题: 如果创建多个对象, 有重复代码
		例子：
			var p = {
				name: 'Tom',
				age: 12,
				setName: function (name) {
					this.name = name
				}
			}
	3. 工厂模式
		* 套路: 通过工厂函数动态创建对象并返回
		* 适用场景: 需要创建多个对象
		* 问题: 对象没有一个具体的类型, 都是Object类型
		例子：
			function createPerson(name, age) { //返回一个对象的函数===>工厂函数
				var obj = {
				name: name,
				age: age,
				setName: function (name) {
						this.name = name
					}
				}

				return obj
			}
			// 创建2个人 （创建的都是Object对象，区分不了具体的类型）
			var p1 = createPerson('Tom', 12)
			var p2 = createPerson('Bob', 13)
	4. 自定义构造函数模式
		* 套路: 自定义构造函数, 通过new创建对象
		* 适用场景: 需要创建多个类型确定的对象
		* 问题: 每个对象都有相同的数据, 浪费内存(需要将方法，存放到原型对象中)
		例子：
			function Person(name, age) {
				this.name = name
				this.age = age
				this.setName = function (name) {
					this.name = name
				}
			}
			function Student (name, price) {
				this.name = name
				this.price = price
			}
			var s = new Student('Bob', 13000)
			var p1 = new Person('Tom', 12)
	5. 构造函数+原型的组合模式
		* 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上
		* 适用场景: 需要创建多个类型确定的对象
		例子：
			function Person(name, age) { //在构造函数中只初始化一般函数
				this.name = name
				this.age = age
			}
			Person.prototype.setName = function (name) {
				this.name = name
			}

			var p1 = new Person('Tom', 23)
			var p2 = new Person('Jack', 24)

十三、 原型链继承
	方式1: 原型链继承
		1. 套路
			a. 定义父类型构造函数
			b. 给父类型的原型添加方法
			c. 定义子类型的构造函数
			d. 创建父类型的对象赋值给子类型的原型
			e. 将子类型原型的构造属性设置为子类型
			f. 给子类型原型添加方法
			g. 创建子类型的对象: 可以调用父类型的方法
		2. 关键
			* 子类型的原型为父类型的一个实例对象
		例子：
			//a.定义父类型构造函数
			function Supper() {
				this.supProp = 'Supper property'
			}
			//b.给父类型原型添加方法
			Supper.prototype.showSupperProp = function () {
				console.log(this.supProp)
			}
			//c.定义子类型构造函数
			function Sub() {
				this.subProp = 'Sub property'
			}
			//d.子类型的原型为父类型的一个实例对象(关键)
			Sub.prototype = new Supper()
			//e.让子类型的原型的constructor指向子类型
			Sub.prototype.constructor = Sub
			//f.给子类型原型添加方法
			Sub.prototype.showSubProp = function () {
				console.log(this.subProp)
			}
			//g.创建子类型的对象: 可以调用父类型的方法
			var sub = new Sub()
			sub.showSupperProp()
	方式2: 借用构造函数继承(假的)
		1. 套路:
			a. 定义父类型构造函数
			b. 定义子类型构造函数
			c. 在子类型构造函数中调用父类型构造
		2. 关键:
			* 在子类型构造函数中通用call()调用父类型构造函数
		例子：
			function Person (name ,age){
				this.name=name;
				this.age=age
			}
			function Student (name ,age ,price){
				Person.call(this ,name ,age)  //相当于this.Person (name ,age) (不这么写，因为其中并没有Person，所以要用call)
				//this.name = name;
				//this,age = age;
				this.price = price
			}
			var s =new Student ('Tom' ,20 , 14000)
			console.log (s.name ,s.age ,s.price)
	方式3: 原型链+借用构造函数的组合继承
		1. 利用原型链实现对父类型对象的方法继承
		2. 利用super()借用父类型构建函数初始化相同属性
		例子：
			function Person (name ,age ){
				this.name=name
				this.age=age
			}
			Person.prototype.setName =function (name){
				this.name=name
			}
			function Student(name ,age ,price){
				Person.call(this ,name ,age) // 为了得到属性
				this.price= price
			}
			Student.prototype = new Person () //为了能看到父类型的方法
			Student.prototype.constructor = Student //修正
			Student.prototype.setPrice =function (price){
				this.price =price
			}
			//使用
			var s =new Student ('Tom' ,24 ,15000)
			s.setName('Bob')
			s.setPrice(16000)
			console.log(s.name ,s.age ,s.price)
十四、 进程与线程
	1. 进程：程序的一次执行, 它占有一片独有的内存空间
	2. 线程：CPU的基本调度单位, 是程序执行的一个完整流程
	3. 进程与线程
		* 一个进程中一般至少有一个运行的线程: 主线程
		* 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
		* 一个进程内的数据可以供其中的多个线程直接共享
		* 多个进程之间的数据是不能直接共享的
	4. 浏览器运行是单进程还是多进程?
		- 有的是单进程
			* firefox
			* 老版IE
		- 有的是多进程
			* chrome
			* 新版IE
	5. 如何查看浏览器是否是多进程运行的呢?
		* 任务管理器==>进程
	6. 浏览器运行是单线程还是多线程?
		* 都是多线程运行的

十五、 浏览器内核
	1. 什么是浏览器内核?
		* 支持浏览器运行的最核心的程序
	2. 不同的浏览器可能不太一样
		* Chrome, Safari: webkit
		* firefox: Gecko
		* IE: Trident
		* 360,搜狗等国内浏览器: Trident + webkit
	3. 内核由很多模块组成
		* html,css文档解析模块 : 负责页面文本的解析
		* dom/css模块 : 负责dom/css在内存中的相关处理
		* 布局和渲染模块 : 负责页面的布局和效果的绘制
		以上是主线程运行的，以下是分线程运行
		* 定时器模块 : 负责定时器的管理
		* 网络请求模块 : 负责服务器请求(常规/Ajax)
		* DOM事件响应模块 : 负责事件的管理

十六、 JS是单线程的
	1. 如何证明js执行是单线程的?
		* setTimeout()的回调函数是在主线程执行的
		* 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
			* 定时器并不能保证真正定时执行
			* 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)
	2. 为什么js要用单线程模式, 而不用多线程模式?
		* JavaScript的单线程，与它的用途有关。
		* 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。
		* 这决定了它只能是单线程，否则会带来很复杂的同步问题
	3. 代码的分类:
		* 初始化代码
		* 回调代码 （回调函数包含的代码，什么是回调函数：①你定义的②你没有调用③但是它最终执行了）
	4. js引擎执行代码的基本流程
		* 先执行初始化代码: 包含一些特别的代码   回调函数(异步执行：只有当所有的初始化代码执行完后才会看情况进行执行)
			* 设置定时器
			* 绑定事件监听
			* 发送ajax请求
		* 后面在某个时刻才会执行回调代码

十七、 事件循环模型
	1. 所有代码分类
		* 初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
		* 回调执行代码(异步代码): 处理回调逻辑
	2. js引擎执行代码的基本流程:
		* 初始化代码===>回调代码
	3. 模型的2个重要组成部分:
		* 事件(定时器/DOM事件/Ajax)管理模块
		* 回调队列
	4. 模型的运转流程
		* 执行初始化代码, 将事件回调函数交给对应模块管理
		* 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
		* 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行

十八、 Web Workers
	1. H5规范提供了js分线程的实现, 取名为: Web Workers
	2. 相关API
		* Worker: 构造函数, 加载分线程执行的js文件
		* Worker.prototype.onmessage: 用于接收另一个线程的回调函数
		* Worker.prototype.postMessage: 向另一个线程发送消息
	3. 不足
		* worker内代码不能操作DOM(更新UI)
		* 不能跨域加载JS
		* 不是每个浏览器都支持这个新特性
















