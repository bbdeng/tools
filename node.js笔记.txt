https://blog.csdn.net/jiangxinyu50/article/details/79104016 破解webstorm
1.命令行窗口(小黑屏)、CMD窗口、终端、shell
	- 开始菜单 --> 运行 --> CMD --> 回车
	- 常用的指令：
		dir 列出当前目录下的所有文件
		cd 目录名 进入到指定的目录
		md 目录名 创建一个文件夹
		rd 目录名 删除一个文件夹
		node 文件名 可以执行js文件	

	- 目录
		. 表示当前目录
		.. 表示上一级目录
		
	- 环境变量（windows系统中变量）	
		path
			C:\work\jdk\jdk1.7.0_75/bin;
			%CATALINA_HOME%/bin;
			C:\work\soft\tools\AppServ\Apache24\bin;
			C:\work\soft\tools\AppServ\php5;
			C:\Users\lilichao\AppData\Local\Programs\Fiddler;
			C:\work\environment\Egret\Egret Wing 3\bin;
			C:\Users\lilichao\AppData\Roaming\npm;
			C:\Program Files\MongoDB\Server\3.2\bin;
			C:\Users\lilichao\Desktop\hello
			
		- 当我们在命令行窗口打开一个文件，或调用一个程序时，
			系统会首先在当前目录下寻找文件程序，如果找到了则直接打开
			如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止
			如果没找到则报错
			

		- 所以我们可以将一些经常需要访问的程序和文件的路径添加到path中，
			这样我们就可以在任意位置来访问这些文件和程序了


2.I/O (Input/Output)
	- I/O操作指的是对磁盘的读写操作
	
3.Node.js简介
	- Node是对ES标准一个实现，Node也是一个JS引擎
	- 通过Node可以使js代码在服务器端执行
	- Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM	
	- Node中可以使用所有的内建对象
		String Number Boolean Math Date RegExp Function Object Array
		而BOM和DOM都不能使用
			但是可以使用 console 也可以使用定时器（setTimeout() setInterval()）
			
	- Node可以在后台来编写服务器
		Node编写服务器都是单线程的服务器
		- 进程
			- 进程就是一个一个的工作计划（工厂中的车间）
		- 线程
			- 线程是计算机最小的运算单位（工厂中的工人）
				线程是干活的
				
	- 传统的服务器都是多线程的
		- 每进来一个请求，就创建一个线程去处理请求
		
	- Node的服务器单线程的
		- Node处理请求时是单线程，但是在后台拥有一个I/O线程池

4.模块化
	- 在Node中，一个js文件就是一个模块
	- 在Node中，每一个js文件中的js代码都是独立运行在一个函数中
		而不是全局作用域，所以一个模块的中的变量和函数在其他模块中无法访问

	- 我们可以通过 exports 来向外部暴露变量和方法
	  	只需要将需要暴露给外部的变量或方法设置为exports的属性即可

		exports.x = "我是02.module.js中的x";
		exports.y = "我是y";
		exports.fn = function () {

		};
	- 在node中，通过require()函数来引入外部的模块
		require()可以传递一个文件的路径作为参数，node将会自动根据该路径来引入外部模块
		这里路径，如果使用相对路径，必须以.或..开头

		使用require()引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块
	- 我们使用require()引入外部模块时，使用的就是模块标识，我们可以通过模块标识来找到指定的模块
	- 模块分成两大类
		核心模块
			- 由node引擎提供的模块
			- 核心模块的标识就是，模块的名字
		文件模块
			- 由用户自己创建的模块
			- 文件模块的标识就是文件的路径（绝对路径，相对路径）
				相对路径使用.或..开头
	- 在node中有一个全局对象 global，它的作用和网页中window类似
		在全局中创建的变量都会作为global的属性保存
		在全局中创建的函数都会作为global的方法保存

	当node在执行模块中的代码时，它会首先在代码的最顶部，添加如下代码
 			function (exports, require, module, __filename, __dirname) {

 	在代码的最底部，添加如下代码
 			}

 	实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参
		 exports
		 	- 该对象用来将变量或函数暴露到外部

		 require
		 	- 函数，用来引入外部的模块

		 module
		 	- module代表的是当前模块本身
		 	- exports就是module的属性
		 	- 既可以使用 exports 导出，也可以使用module.exports导出

		 __filename
 			C:\Users\lilichao\WebstormProjects\class0705\01.node\04.module.js
 			- 当前模块的完整路径

	  	 __dirname
 			C:\Users\lilichao\WebstormProjects\class0705\01.node
 			- 当前模块所在文件夹的完整路径
	- - 模块的引用
				- 使用 require()函数来引入一个模块
				- 例子：
					var 变量 = require("模块的标识");
				
			- 模块的定义
				- 在node中一个js文件就是一个模块
				- 默认情况下在js文件中编写的内容，都是运行在一个独立的函数中，
					外部的模块无法访问
				- 导出变量和函数
					- 使用 exports 
						- 例子：
							exports.属性 = 属性值;
							exports.方法 = 函数;
							
					- 使用module.exports
						- 例子：
							module.exports.属性 = 属性值;
							module.exports.方法 = 函数;
							module.exports = {};

5.package 包的简介   包含有以下文件
	-package.json  描述文件 （必须）
	-bin   	       可执行二进制文件
	-lib	       js代码
	-doc	       文档
	-test	       单元测试

	强制自动生成包 npm init --yes
	自己指定       npm init
6.npm的命令
			- npm -v 查看npm的版本
			- npm version 查看所有模块的版本
			- npm search 包名 搜索包
			- npm install / i 包名 安装包
			- npm remove / r 包名 删除包
			- npm install 包名 --save 安装包并添加到依赖中 *****
			- npm install 下载当前项目所依赖的包
			- npm install 包名 -g 全局安装包（全局安装的包一般都是一些工具）
			- npm install anywhere -g 下载anywhere全局安装包
			- anywhere 端口号 开启本地服务器
			- npm root -g   查看全局安装路径
			- npmlist       显示当前目录下所有的包
			- npmlist -g    显示全局下所有的包
			- npm uninstall 包名    卸载本地的包
			- npm uninstall 包名 -g 卸载全局下的包
			- npm update 包名   更新本地包
			- npm update -g 包名 更新全局下的包
			- npm update 更新当前目录下所有的包
			- npm update -g 更新全局下所有的包
			- npm shrinkwrap 用来彻底锁定所有模块的版本
			- nom shrinkwrap --dev 加上参数dev，还可以记录devDependencies字段中模块的准确的版本
7.文件系统（File System）
	- Buffer（缓冲区）
		- Buffer和数组的结构的非常类似，Buffer是用来存储二进制数据的
		- Buffer的方法
			- Buffer.from(字符串)
				- 将一个字符串中内容保存到一个buffer中
			- buf.toString()
				- 将buffer转换为一个字符串
			- Buffer.alloc(size)
				- 创建一个指定大小的buffer对象
			- Buffer.allocUnsafe(size)
				- 创建一个指定大小的buffer对象，可以包含敏感数据
				
				
	- fs模块
		- 在Node通过fs模块来对系统中的文件进行操作，fs模块是node中已经继承好了，不需要在使用npm下载，直接引入即可
		- 引入fs
			var fs = require("fs");
		- fs模块中的大部分操作都提供了两种方法，同步方法和异步方法
			同步方法带sync
			异步方法没有sync，都需要回调函数
			
		- 写入文件
			1.同步写入
			2.异步写入
			3.简单写入
			4.流式写入
			
		- 读取文件
			1.同步读取
			2.异步读取
			3.简单读取
			4.流式读取
			
		- 方法
			- 打开文件
				fs.open(path, flags[, mode], callback)
					- 回调函数的参数①err 错误对象，如果没有错误则为null ②fd 文件的描述符
				fs.openSync(path, flags[, mode])
					- path 要打开文件的路径
					- flags 打开文件要求操作的类型
						r 只读的 w可写的 a追加
					- mode 设置文件的操作权限，一般不传

			- 读写文件
				fs.write(fd, string[, position[, encoding]], callback)
					- 回调函数的参数①err ②written被写入多少字节 ③写入的内容 
				fs.writeSync(fd, string[, position[, encoding]])
					- fd 文件的描述符，需要传入要写入文件的描述符
					- string 要写入的内容
					- position 写入的起始位置 不管
					- encoding 编码类型 默认utf-8
				fs.read(fd, buffer, offset, length, position, callback)
				fs.readSync(fd, buffer, offset, length, position)
				
			- 关闭文件
				fs.close(fd,callback)
				fs.closeSync(fd);
					- fd 文件的描述符，需要传入要关闭的文件的描述符
			- 简单文件读取和写入
				fs.writeFile(file, data[, options], callback)
				fs.writeFileSync(file, data[, options])
					- file 要操作的文件路径
					- data 要写入的数据
					- options 选项，可以对写入进行一些设置
				fs.readFile(path[, options], callback)
				fs.readFileSync(path[, options])
				
				
			- 流式文件读取和写入
				- 流式读取和写入适用于一些比较大的文件
					var ws=fs.createWriteStream(path[, options])
					var rsfs.createReadStream(path[, options])
				- 将可读流中的内容，直接输出到可写流
					rs.pipe(ws);
			- 其他操作
				验证路径是否存在 
				C fs.exists(path，callback) C fs.existsSync(path)
				获取文件信息 
				C fs.stat(path, callback) C fs.statSync(path)
				删除文件 
				C fs.unlink(path, callback) C fs.unlinkSync(path)
				列出文件 
				C fs.readdir(path[, options], callback) C fs.readdirSync(path[, options])
				截断文件 
				C fs.truncate(path, len, callback) C fs.truncateSync(path, len)
				建立目录 
				C fs.mkdir(path[, mode], callback) C fs.mkdirSync(path[, mode])
				删除目录 
				C fs.rmdir(path, callback) C fs.rmdirSync(path)
				重命名文件和目录 
				C fs.rename(oldPath, newPath, callback) C fs.renameSync(oldPath, newPath)
				监视文件更改写入 
				C fs.watchFile(filename[, options], listener)


8.各种第三方包及其用法

	mime 包
		-mime.lookup(url)   
			通过url获取文件的后缀名用来设置响应头类型



	mongoose 包
		- mongoose.connect('mongodb://数据库IP地址：端口号/数据库名',{useMongoClient:true})  
			链接mongoose数据库,如果端口号默认是27017，则可以不用填写
		- mongoose.connection.once("open",function () {
    								console.log("数据库链接成功!");
								});
		- mongoose.connection.once("close",function () {
    								console.log("数据库断开成功!");
								});
			监听服务器的链接状态
		- var Schema=mongoose.Schema;
		  var stuSchema=new Schema({
    						name:String,
   						age:Number,
   						gender:{
     					   	type:String,
        					default:"female"
    						},
    						address:String
						});
			创建Schema(模式)对象
		-var StuModel=mongoose.model("students",stuSchema);
			创建Model，Model表示数据库里面的集合，2个参数，第1个表示集合的名字，第2个表示用哪个对象来约束集合
		- 查询Model.find(conditions,[projection],[options],callback)
		     Model.findById(id,[projection],[options],callback)
		     Model.findOne(conditions,[projection],[options],callback)
				conditions 查询的条件
				projection 投影  传统{name:1,_id:0}  另一种"name -_id_"
				options 查询选项(skip  limit )
		- 修改 Model.update(conditions ,doc ,[options] ,callback)
		      Model.updateMany(conditions ,doc ,[options] ,callback)
		      Model.updateOne(conditions ,doc ,[options] ,callback)
		- 删除 Model.remove(conditions,callback)
		      Model.deleteOne(conditions,callback)
	              Model.deleteMany(conditions,callback)
		- 统计 Model.count(conditions,callback)
	
	md5-node模块
		- 1安装 npm install md5-node --save
		- 2引入 var md5=require("md5-node")
		- 3使用 md5(123456);
	

	express框架
		- var express=require('express');  /*引入 express*/ 
		- var app=new express(); /*实例化 express 赋值给 app*/ 
		- app.get("网址",function(req,res){   });   当用 get 请求访问一个网址的时候，做什么事情：
		  app.post("网址",function(req,res){   });  当用 post 访问一个网址的时候，做什么事情： 
		  app.put('/user', function (req, res) {   res.send('Got a PUT request at /user'); }); // user 节点接受 PUT 请求 
		  app.delete('/user', function (req, res) {   res.send('Got a DELETE request at /user'); }); // user 节点接受 DELETE 请求 
			简单静态路由配置
		- app.get("/user/:id",function(req,res){ var id = req.params["id"]; res.send(id); }); 
			动态路由配置以及获取动态get传值 
		- /news?id=2&sex=nan 
		  app.get('/news, function(req, res) {    console.log(req.query); });  路由里面获取 Get 传值
		- 托管静态文件
		  app.use(express.static("public"));  给public目录下面的托管静态文件
		  匹配虚拟目录的静态web服务
		  app.use("/status",express.static("public"))
		- 中间件：就是匹配路由之前和匹配路由之后做的一系列操作
		  1.应用级中间件 表示匹配任何路由
			app.use(function (req, res ,next) {
								console.log(new Date());
								next();//路由继续向下匹配
							})
		  2.路由中间件    next()路由继续向下匹配
			app.get("/news",function (req, res,next) {
    									console.log("这是路由中间件");
   									next();
								})
			app.get("/news",function (req, res) {
    									res.send("这是路由中间件news2");
								})
		  3.内置中间件 托管静态页面
			app.use(express.static("public"));
		  4.错误处理中间件
			app.use(function (req, res) {
    							res.status(404).send("404错误 表示路由没有匹配到");
						   })
		-  登陆成功直接跳转页面res.redirect("/product")


		
		 
	express框架中的ejs包使用
		- 安装 npm install ejs --save
		- app.set("view engine","ejs");  //配置ejs模板引擎
		- ejs前台模板文件默认目录放在views下  可以通过app.set("views",_dirname+"/目录名"); 来重新指定新的ejs模板地址
		- var arr =["111","222","333"]
  		  res.render("index" ,{list:arr})//ejs渲染模板 第1个参数为在view下需要渲染的模板引擎名字，第2个参数为需要渲染到前台的数据
		- 引入外部公共的ejs文件<%- include ../public/header.ejs  %>
		- 注册html模板引擎
		  app.engine("html",ejs._express);
		  将模板引擎换成html
		  app.set("view engine","html");  然后就可以创建后缀名为html的模板引擎了
		- 设置全局变量 可以在任何页面显示
		  app.locals["username"]=req.session.userinfo.username

	express框架中获取post传值的body-parser包
		- 引入模块
			var bodyParser=require("body-parser");
		- 配置
			app.use(bodyParser.urlencoded({ extended: false }));
			app.use(bodyParser.json());
		- 获取post传值
			req.body

	multiparty模块解决图片上传以及post提交表单数据问题
		- 安装 npm install multiparty --save
		- 引入 var multiparty=require("multiparty");
		- 使用 var addProduct=new multiparty.Form();
		       addProduct.uploadDir="upload-img";  //上传图片保存地址
		       addProduct.parse(req,function(err,fields,files){
					console.log(fields);  //表单提交过来的文字信息
					console.log(files);  //表单提交过来的图片信息
			})



		
	cookie  - cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名的时候共享数据。
		- 1.安装 cnpm instlal cookie-parser --save
		  2.引入 var cookieParser = require('cookie-parser');
		  3.设置中间件
		  app.use(cookieParser());
		  4.设置 cookie   第1个参数是cookie的名字 第2个是cookie的值 第3个是属性
		  res.cookie("name",'zhangsan',{maxAge: 900000, httpOnly: true}); 
		  HttpOnly 默认 false 不允许 客户端脚本访问
		  5.获取 cookie
		  req.cookies.name
		- 第3个参数cookie的属性
		  属性说明
			- domain: 域名   例如：.aaa.com  多个2级域名共享cookie信息
			  C:\Windows\System32\drivers\etc  下的hosts 设置本地的ip域名
			- Expires： 过期时间（秒），在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday,
			- res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly:true });
			- maxAge： 最大失效时间（毫秒），设置在多少后失效
			- secure： 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效
			- Path： 表示 在哪个路由下面可以访问cookie ，如 path=/。如果路径不能匹配时，浏览器则不发送这个 Cookie
			- httpOnly：是微软对 COOKIE 做的扩展。如果在 COOKIE 中设置了“httpOnly”属性为true，则通过程序（JS脚本、applet 等）将无法读取到COOKIE 信息，防止 XSS 攻击产生
			- singed：表示是否签名cookie, 设为true 会对这个 cookie 签名，这样就需要用res.signedCookies 而不是 res.cookies 访问它。被篡改的签名 cookie 会被服务器拒绝，并且 cookie值会重置为它的原始值
		        - 加密cookie
			1.配置中间件的时候需要传参
			app.use(cookieParser('123456')); 123456其实可以随便传入
		 	2. 设置 cookie  的时候配置 signed为true
			res.cookie('userinfo','hahaha',{domain:'.ccc.com',maxAge:900000,httpOnly:true,signed:true});
			3.signedCookies  调用设置的 cookie
			console.log(req.signedCookies);
	session - session  （包名叫express-session）是另一种记录客户状态的机制，不同的是 Cookie  保存在客户端浏览器中，而 session  保存在服务器上。
		  session 与cookie的区别 关闭浏览器记录会清空
		  1.安装 express-session
		  2.引入 express-session   var session=require("express-session");
		  3.设置官方文档提供的中间件
			app.use(session({
    					secret: 'keyboard cat',
   					resave: false,
    					saveUninitialized: true
					}));
		  4.设置session   req.session.urseinfo="帮办";
		  5.获取session   req.session.urseinfo 
		  6.退出session   req.session.cookie.maxAge=0; 重新设置 cookie 的过期时间  
		                  req.session.destroy(function(err) { })   销毁登陆
		- session设置中间件时候的一些属性
			secret 可以随便设置加密,一个 String 类型的字符串，作为服务器端生成 session 的签名。
			name  返回客户端的 key 的名称，默认为 connect.sid,也可以自己设置。
			resave 强制保存 session 即使它并没有变化,。默认为 true。建议设置成 false。
			saveUninitialized  强制将未初始化的 session 存储。当新建了一个 session 且未设定属性或值时，它就处于未初始化状态。在设定一个 cookie 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）。建议手动添加。
			cookie 设置返回到前端 key 的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。
			rolling  在每次请求时强行设置 cookie，如果将其设置为true,这将重置 cookie 过期时间（默认：false）
		- 将session 的信息保存到数据库
		  1.需要安装 express-session 和 connect-mongo 模块
		  2.引入模块
			var session = require("express-session");
			var connectMongo=require("connect-mongo")(session);
		  3.配置中间件
			app.use(session({
    					secret: 'this is string key',
    					name:"session_id",
    					resave: false,
    					saveUninitialized: true,
    					cookie:{maxAge:1000*60*30},
    					rolling:true,
    					store:new connectMongo({
        							url:"mongodb://127.0.0.1:27017/test",  //服务器地址
        							touchAfter:24*3600  //通过设置touchAfter：24 * 3600来设置touchAfter：24 * 3600，在24小时内只会更新一次，无论请求的数量是多少（除了那些会改变会话数据的数据）
    								})

				}));
		
		
 
 
 



	
9.状态码
		- 1xx 请求正在处理
		- 2xx 正常处理完成
			200 OK 请求成功
		- 3xx 重定向
			301 Moved Permanently 永久重定向
			302 Found 临时重定向
		- 4xx 客户端错误
			400 Bad Request 语法错误
			401 Unauthorized 权限未认证
			403 Forbidden 禁止访问
			404 Not Found 资源未找到
		- 5xx 服务器端错误
			500 Internal Server 
10.http模块	
		-function sverve(res,req){
					 res.writeHead(404 ,{"Content-Type":"text/html; charset=utf-8"});//响应头
					 res.write(data404);
					 res.end();
				}
		-var sverver=http.createServer(sverve)  创建服务器
		-server.listen(8055 );   监听端口
11.url模块	
		-分布图解析请访问 http://nodejs.cn/api/url.html#url_constructor_new_url_input_base
		-var urlObj=url.parse(req.url,true);
			表示将请求转化为对象，第1个参数为请求url 第2个参数true表示将query查询字符串转换为对象
		-var pathname=urlObj.pathname
			获取路径名

12.buffer 
		3种构建buffer的方法
	      - var buf1=new Buffer(3);
		buf1[0]=0x61;buf1[1]=0x62;buf1[2]=0x63;
	      - var buf2=new Buffer([0x61,0x62,0x63]);
	      - var buf3=new Buffer("abc");
		buf1==buf2==buf3
	
		












































