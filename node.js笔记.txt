https://blog.csdn.net/jiangxinyu50/article/details/79104016 破解webstorm
1.命令行窗口(小黑屏)、CMD窗口、终端、shell
	- 开始菜单 --> 运行 --> CMD --> 回车
	- 常用的指令：
		dir 列出当前目录下的所有文件
		cd 目录名 进入到指定的目录
		md 目录名 创建一个文件夹
		rd 目录名 删除一个文件夹
		node 文件名 可以执行js文件	

	- 目录
		. 表示当前目录
		.. 表示上一级目录
		
	- 环境变量（windows系统中变量）	
		path
			C:\work\jdk\jdk1.7.0_75/bin;
			%CATALINA_HOME%/bin;
			C:\work\soft\tools\AppServ\Apache24\bin;
			C:\work\soft\tools\AppServ\php5;
			C:\Users\lilichao\AppData\Local\Programs\Fiddler;
			C:\work\environment\Egret\Egret Wing 3\bin;
			C:\Users\lilichao\AppData\Roaming\npm;
			C:\Program Files\MongoDB\Server\3.2\bin;
			C:\Users\lilichao\Desktop\hello
			
		- 当我们在命令行窗口打开一个文件，或调用一个程序时，
			系统会首先在当前目录下寻找文件程序，如果找到了则直接打开
			如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止
			如果没找到则报错
			

		- 所以我们可以将一些经常需要访问的程序和文件的路径添加到path中，
			这样我们就可以在任意位置来访问这些文件和程序了


2.I/O (Input/Output)
	- I/O操作指的是对磁盘的读写操作
	
3.Node.js简介
	- Node是对ES标准一个实现，Node也是一个JS引擎
	- 通过Node可以使js代码在服务器端执行
	- Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM	
	- Node中可以使用所有的内建对象
		String Number Boolean Math Date RegExp Function Object Array
		而BOM和DOM都不能使用
			但是可以使用 console 也可以使用定时器（setTimeout() setInterval()）
			
	- Node可以在后台来编写服务器
		Node编写服务器都是单线程的服务器
		- 进程
			- 进程就是一个一个的工作计划（工厂中的车间）
		- 线程
			- 线程是计算机最小的运算单位（工厂中的工人）
				线程是干活的
				
	- 传统的服务器都是多线程的
		- 每进来一个请求，就创建一个线程去处理请求
		
	- Node的服务器单线程的
		- Node处理请求时是单线程，但是在后台拥有一个I/O线程池

4.模块化
	- 在Node中，一个js文件就是一个模块
	- 在Node中，每一个js文件中的js代码都是独立运行在一个函数中
		而不是全局作用域，所以一个模块的中的变量和函数在其他模块中无法访问

	- 我们可以通过 exports 来向外部暴露变量和方法
	  	只需要将需要暴露给外部的变量或方法设置为exports的属性即可

		exports.x = "我是02.module.js中的x";
		exports.y = "我是y";
		exports.fn = function () {

		};
	- 在node中，通过require()函数来引入外部的模块
		require()可以传递一个文件的路径作为参数，node将会自动根据该路径来引入外部模块
		这里路径，如果使用相对路径，必须以.或..开头

		使用require()引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块
	- 我们使用require()引入外部模块时，使用的就是模块标识，我们可以通过模块标识来找到指定的模块
	- 模块分成两大类
		核心模块
			- 由node引擎提供的模块
			- 核心模块的标识就是，模块的名字
		文件模块
			- 由用户自己创建的模块
			- 文件模块的标识就是文件的路径（绝对路径，相对路径）
				相对路径使用.或..开头
	- 在node中有一个全局对象 global，它的作用和网页中window类似
		在全局中创建的变量都会作为global的属性保存
		在全局中创建的函数都会作为global的方法保存

	当node在执行模块中的代码时，它会首先在代码的最顶部，添加如下代码
 			function (exports, require, module, __filename, __dirname) {

 	在代码的最底部，添加如下代码
 			}

 	实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参
		 exports
		 	- 该对象用来将变量或函数暴露到外部

		 require
		 	- 函数，用来引入外部的模块

		 module
		 	- module代表的是当前模块本身
		 	- exports就是module的属性
		 	- 既可以使用 exports 导出，也可以使用module.exports导出

		 __filename
 			C:\Users\lilichao\WebstormProjects\class0705\01.node\04.module.js
 			- 当前模块的完整路径

	  	 __dirname
 			C:\Users\lilichao\WebstormProjects\class0705\01.node
 			- 当前模块所在文件夹的完整路径
	- - 模块的引用
				- 使用 require()函数来引入一个模块
				- 例子：
					var 变量 = require("模块的标识");
				
			- 模块的定义
				- 在node中一个js文件就是一个模块
				- 默认情况下在js文件中编写的内容，都是运行在一个独立的函数中，
					外部的模块无法访问
				- 导出变量和函数
					- 使用 exports 
						- 例子：
							exports.属性 = 属性值;
							exports.方法 = 函数;
							
					- 使用module.exports
						- 例子：
							module.exports.属性 = 属性值;
							module.exports.方法 = 函数;
							module.exports = {};

5.package 包的简介   包含有以下文件
	-package.json  描述文件 （必须）
	-bin   	       可执行二进制文件
	-lib	       js代码
	-doc	       文档
	-test	       单元测试

	强制自动生成包 npm init --yes
	自己指定       npm init
6.npm的命令
			- npm -v 查看npm的版本
			- npm version 查看所有模块的版本
			- npm search 包名 搜索包
			- npm install / i 包名 安装包
			- npm remove / r 包名 删除包
			- npm install 包名 --save 安装包并添加到依赖中 *****
			- npm install 下载当前项目所依赖的包
			- npm install 包名 -g 全局安装包（全局安装的包一般都是一些工具）
			- npm install anywhere -g 下载anywhere全局安装包
			- anywhere 端口号 开启本地服务器
			- npm root -g   查看全局安装路径
			- npmlist       显示当前目录下所有的包
			- npmlist -g    显示全局下所有的包
			- npm uninstall 包名    卸载本地的包
			- npm uninstall 包名 -g 卸载全局下的包
			- npm update 包名   更新本地包
			- npm update -g 包名 更新全局下的包
			- npm update 更新当前目录下所有的包
			- npm update -g 更新全局下所有的包
			- npm shrinkwrap 用来彻底锁定所有模块的版本
			- nom shrinkwrap --dev 加上参数dev，还可以记录devDependencies字段中模块的准确的版本
7.文件系统（File System）
	- Buffer（缓冲区）
		- Buffer和数组的结构的非常类似，Buffer是用来存储二进制数据的
		- Buffer的方法
			- Buffer.from(字符串)
				- 将一个字符串中内容保存到一个buffer中
			- buf.toString()
				- 将buffer转换为一个字符串
			- Buffer.alloc(size)
				- 创建一个指定大小的buffer对象
			- Buffer.allocUnsafe(size)
				- 创建一个指定大小的buffer对象，可以包含敏感数据
				
				
	- fs模块
		- 在Node通过fs模块来对系统中的文件进行操作，fs模块是node中已经继承好了，不需要在使用npm下载，直接引入即可
		- 引入fs
			var fs = require("fs");
		- fs模块中的大部分操作都提供了两种方法，同步方法和异步方法
			同步方法带sync
			异步方法没有sync，都需要回调函数
			
		- 写入文件
			1.同步写入
			2.异步写入
			3.简单写入
			4.流式写入
			
		- 读取文件
			1.同步读取
			2.异步读取
			3.简单读取
			4.流式读取
			
		- 方法
			- 打开文件
				fs.open(path, flags[, mode], callback)
					- 回调函数的参数①err 错误对象，如果没有错误则为null ②fd 文件的描述符
				fs.openSync(path, flags[, mode])
					- path 要打开文件的路径
					- flags 打开文件要求操作的类型
						r 只读的 w可写的 a追加
					- mode 设置文件的操作权限，一般不传

			- 读写文件
				fs.write(fd, string[, position[, encoding]], callback)
					- 回调函数的参数①err ②written被写入多少字节 ③写入的内容 
				fs.writeSync(fd, string[, position[, encoding]])
					- fd 文件的描述符，需要传入要写入文件的描述符
					- string 要写入的内容
					- position 写入的起始位置 不管
					- encoding 编码类型 默认utf-8
				fs.read(fd, buffer, offset, length, position, callback)
				fs.readSync(fd, buffer, offset, length, position)
				
			- 关闭文件
				fs.close(fd,callback)
				fs.closeSync(fd);
					- fd 文件的描述符，需要传入要关闭的文件的描述符
			- 简单文件读取和写入
				fs.writeFile(file, data[, options], callback)
				fs.writeFileSync(file, data[, options])
					- file 要操作的文件路径
					- data 要写入的数据
					- options 选项，可以对写入进行一些设置
				fs.readFile(path[, options], callback)
				fs.readFileSync(path[, options])
				
				
			- 流式文件读取和写入
				- 流式读取和写入适用于一些比较大的文件
					var ws=fs.createWriteStream(path[, options])
					var rsfs.createReadStream(path[, options])
				- 将可读流中的内容，直接输出到可写流
					rs.pipe(ws);
			- 其他操作
				验证路径是否存在 
				C fs.exists(path，callback) C fs.existsSync(path)
				获取文件信息 
				C fs.stat(path, callback) C fs.statSync(path)
				删除文件 
				C fs.unlink(path, callback) C fs.unlinkSync(path)
				列出文件 
				C fs.readdir(path[, options], callback) C fs.readdirSync(path[, options])
				截断文件 
				C fs.truncate(path, len, callback) C fs.truncateSync(path, len)
				建立目录 
				C fs.mkdir(path[, mode], callback) C fs.mkdirSync(path[, mode])
				删除目录 
				C fs.rmdir(path, callback) C fs.rmdirSync(path)
				重命名文件和目录 
				C fs.rename(oldPath, newPath, callback) C fs.renameSync(oldPath, newPath)
				监视文件更改写入 
				C fs.watchFile(filename[, options], listener)


8.各种第三方包及其用法

	mime 包
		-mime.lookup(url)   
			通过url获取文件的后缀名用来设置响应头类型



	mongoose 包
		- mongoose.connect('mongodb://数据库IP地址：端口号/数据库名',{useMongoClient:true})  
			链接mongoose数据库,如果端口号默认是27017，则可以不用填写
		- mongoose.connection.once("open",function () {
    								console.log("数据库链接成功!");
								});
		- mongoose.connection.once("close",function () {
    								console.log("数据库断开成功!");
								});
			监听服务器的链接状态
		- var Schema=mongoose.Schema;
		  var stuSchema=new Schema({
    						name:String,
   						age:Number,
   						gender:{
     					   	type:String,
        					default:"female"
    						},
    						address:String
						});
			创建Schema(模式)对象
		-var StuModel=mongoose.model("students",stuSchema);
			创建Model，Model表示数据库里面的集合，2个参数，第1个表示集合的名字，第2个表示用哪个对象来约束集合
		- 查询Model.find(conditions,[projection],[options],callback)
		     Model.findById(id,[projection],[options],callback)
		     Model.findOne(conditions,[projection],[options],callback)
				conditions 查询的条件
				projection 投影  传统{name:1,_id:0}  另一种"name -_id_"
				options 查询选项(skip  limit )
		- 修改 Model.update(conditions ,doc ,[options] ,callback)
		      Model.updateMany(conditions ,doc ,[options] ,callback)
		      Model.updateOne(conditions ,doc ,[options] ,callback)
		- 删除 Model.remove(conditions,callback)
		      Model.deleteOne(conditions,callback)
	              Model.deleteMany(conditions,callback)
		- 统计 Model.count(conditions,callback)
	express框架
		- var express=require('express');  /*引入 express*/ 
		- var app=new express(); /*实例化 express 赋值给 app*/ 
		- app.get("网址",function(req,res){   });   当用 get 请求访问一个网址的时候，做什么事情：
		  app.post("网址",function(req,res){   });  当用 post 访问一个网址的时候，做什么事情： 
		  app.put('/user', function (req, res) {   res.send('Got a PUT request at /user'); }); // user 节点接受 PUT 请求 
		  app.delete('/user', function (req, res) {   res.send('Got a DELETE request at /user'); }); // user 节点接受 DELETE 请求 
			简单静态路由配置
		- app.get("/user/:id",function(req,res){ var id = req.params["id"]; res.send(id); }); 
			动态路由配置以及获取动态get传值 
		- /news?id=2&sex=nan 
		  app.get('/news, function(req, res) {    console.log(req.query); });  路由里面获取 Get 传值 
		
 
 
 



	
9.状态码
		- 1xx 请求正在处理
		- 2xx 正常处理完成
			200 OK 请求成功
		- 3xx 重定向
			301 Moved Permanently 永久重定向
			302 Found 临时重定向
		- 4xx 客户端错误
			400 Bad Request 语法错误
			401 Unauthorized 权限未认证
			403 Forbidden 禁止访问
			404 Not Found 资源未找到
		- 5xx 服务器端错误
			500 Internal Server 
10.http模块	
		-function sverve(res,req){
					 res.writeHead(404 ,{"Content-Type":"text/html; charset=utf-8"});//响应头
					 res.write(data404);
					 res.end();
				}
		-var sverver=http.createServer(sverve)  创建服务器
		-server.listen(8055 );   监听端口
11.url模块	
		-分布图解析请访问 http://nodejs.cn/api/url.html#url_constructor_new_url_input_base
		-var urlObj=url.parse(req.url,true);
			表示将请求转化为对象，第1个参数为请求url 第2个参数true表示将query查询字符串转换为对象
		-var pathname=urlObj.pathname
			获取路径名

12.buffer 
		3种构建buffer的方法
	      - var buf1=new Buffer(3);
		buf1[0]=0x61;buf1[1]=0x62;buf1[2]=0x63;
	      - var buf2=new Buffer([0x61,0x62,0x63]);
	      - var buf3=new Buffer("abc");
		buf1==buf2==buf3
	
		












































