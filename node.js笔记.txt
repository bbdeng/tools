https://blog.csdn.net/jiangxinyu50/article/details/79104016 破解webstorm
1.命令行窗口(小黑屏)、CMD窗口、终端、shell
	- 开始菜单 --> 运行 --> CMD --> 回车
	- 常用的指令：
		ipconfig / ipconfig -all  查看自己的电脑IP地址
		ping www.baidu.com -t 查看自己的网络延迟状态
		exit 关掉DOS命令窗口
		cls 清屏
		D: 直接进入到D盘
		dir 列出当前目录下的所有文件
		cd 目录名 进入到指定的目录
		md 目录名 创建一个文件夹
		rd 目录名 删除一个文件夹
		node 文件名 可以执行js文件	

	- 目录
		. 表示当前目录
		.. 表示上一级目录
		
	- 环境变量（windows系统中变量）	
		path
			C:\work\jdk\jdk1.7.0_75/bin;
			%CATALINA_HOME%/bin;
			C:\work\soft\tools\AppServ\Apache24\bin;
			C:\work\soft\tools\AppServ\php5;
			C:\Users\lilichao\AppData\Local\Programs\Fiddler;
			C:\work\environment\Egret\Egret Wing 3\bin;
			C:\Users\lilichao\AppData\Roaming\npm;
			C:\Program Files\MongoDB\Server\3.2\bin;
			C:\Users\lilichao\Desktop\hello
			
		- 当我们在命令行窗口打开一个文件，或调用一个程序时，
			系统会首先在当前目录下寻找文件程序，如果找到了则直接打开
			如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止
			如果没找到则报错
			

		- 所以我们可以将一些经常需要访问的程序和文件的路径添加到path中，
			这样我们就可以在任意位置来访问这些文件和程序了
	- 服务器端口号:(0-65535)
		* 一般默认端口http找80，https找443，ftp找21端口
		


2.I/O (Input/Output)
	- I/O操作指的是对磁盘的读写操作
	
3.Node.js简介
	- Node是对ES标准一个实现，Node也是一个JS引擎
	- 通过Node可以使js代码在服务器端执行
	- Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM	
	- Node中可以使用所有的内建对象
		String Number Boolean Math Date RegExp Function Object Array
		而BOM和DOM都不能使用
			但是可以使用 console 也可以使用定时器（setTimeout() setInterval()）
	- Node && 浏览器
		* node采用的是谷歌的V8引擎来渲染JS的(运行速度快，稳定，编写代码不考虑兼容)
		* 浏览器中的全局JS对象是window，而node环境下的全局JS对象是Global
		* 浏览器不可能提供用JS对客户电脑磁盘上的文件进行操作的功能；但是node环境提供了对应的I/O操作(服务器上文件的操作)，我们使用JS可以对服务器磁盘下的文件进行增删改查。
			
	- Node可以在后台来编写服务器
		Node编写服务器都是单线程的服务器
		- 进程
			- 进程就是一个一个的工作计划（工厂中的车间）
		- 线程
			- 线程是计算机最小的运算单位（工厂中的工人）
				线程是干活的
				
	- 传统的服务器都是多线程的
		- 每进来一个请求，就创建一个线程去处理请求
		
	- Node的服务器单线程的
		- Node处理请求时是单线程，但是在后台拥有一个I/O线程池

4.模块化
	- 在Node中，一个js文件就是一个模块
	- 在Node中，每一个js文件中的js代码都是独立运行在一个函数中
		而不是全局作用域，所以一个模块的中的变量和函数在其他模块中无法访问

	- 我们可以通过 exports 来向外部暴露变量和方法
	  	只需要将需要暴露给外部的变量或方法设置为exports的属性即可

		exports.x = "我是02.module.js中的x";
		exports.y = "我是y";
		exports.fn = function () {

		};
	- 在node中，通过require()函数来引入外部的模块
		require()可以传递一个文件的路径作为参数，node将会自动根据该路径来引入外部模块
		这里路径，如果使用相对路径，必须以.或..开头

		使用require()引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块
	- 我们使用require()引入外部模块时，使用的就是模块标识，我们可以通过模块标识来找到指定的模块
	- 模块分成两大类
		核心模块
			- 由node引擎提供的模块
			- 核心模块的标识就是，模块的名字
		文件模块
			- 由用户自己创建的模块
			- 文件模块的标识就是文件的路径（绝对路径，相对路径）
				相对路径使用.或..开头
	- 在node中有一个全局对象 global，它的作用和网页中window类似
		在全局中创建的变量都会作为global的属性保存
		在全局中创建的函数都会作为global的方法保存

	当node在执行模块中的代码时，它会首先在代码的最顶部，添加如下代码
 			function (exports, require, module, __filename, __dirname) {

 	在代码的最底部，添加如下代码
 			}

 	实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参
		 exports
		 	- 该对象用来将变量或函数暴露到外部

		 require
		 	- 函数，用来引入外部的模块

		 module
		 	- module代表的是当前模块本身
		 	- exports就是module的属性
		 	- 既可以使用 exports 导出，也可以使用module.exports导出

		 __filename
 			C:\Users\lilichao\WebstormProjects\class0705\01.node\04.module.js
 			- 当前模块的完整路径

	  	 __dirname
 			C:\Users\lilichao\WebstormProjects\class0705\01.node
 			- 当前模块所在文件夹的完整路径
	- - 模块的引用
				- 使用 require()函数来引入一个模块
				- 例子：
					var 变量 = require("模块的标识");
				
			- 模块的定义
				- 在node中一个js文件就是一个模块
				- 默认情况下在js文件中编写的内容，都是运行在一个独立的函数中，
					外部的模块无法访问
				- 导出变量和函数
					- 使用 exports 
						- 例子：
							exports.属性 = 属性值;
							exports.方法 = 函数;
							
					- 使用module.exports
						- 例子：
							module.exports.属性 = 属性值;
							module.exports.方法 = 函数;
							module.exports = {};

5.package 包的简介   包含有以下文件
	-package.json  描述文件 （必须）
	-bin   	       可执行二进制文件
	-lib	       js代码
	-doc	       文档
	-test	       单元测试

	强制自动生成包 npm init --yes
	自己指定       npm init
6.npm的命令
			- npm -v 查看npm的版本
			- npm version 查看所有模块的版本
			- npm search 包名 搜索包
			- npm install / i 包名 安装包
			- npm remove / r 包名 删除包
			- npm install 包名 --save 安装包并添加到依赖中 *****
			- npm install 下载当前项目所依赖的包
			- npm install 包名 -g 全局安装包（全局安装的包一般都是一些工具）
			- npm install anywhere -g 下载anywhere全局安装包
			- anywhere 端口号 开启本地服务器
			- npm root -g   查看全局安装路径
			- npmlist       显示当前目录下所有的包
			- npmlist -g    显示全局下所有的包
			- npm uninstall 包名    卸载本地的包
			- npm uninstall 包名 -g 卸载全局下的包
			- npm update 包名   更新本地包
			- npm update -g 包名 更新全局下的包
			- npm update 更新当前目录下所有的包
			- npm update -g 更新全局下所有的包
			- npm shrinkwrap 用来彻底锁定所有模块的版本
			- npm shrinkwrap --dev 加上参数dev，还可以记录devDependencies字段中模块的准确的版本
			- npm uninstall 包名 -g 全局卸载指定包
7.文件系统（File System）
	- Buffer（缓冲区）
		- Buffer和数组的结构的非常类似，Buffer是用来存储二进制数据的
		- Buffer的方法
			- Buffer.from(字符串)
				- 将一个字符串中内容保存到一个buffer中
			- buf.toString()
				- 将buffer转换为一个字符串
			- Buffer.alloc(size)
				- 创建一个指定大小的buffer对象
			- Buffer.allocUnsafe(size)
				- 创建一个指定大小的buffer对象，可以包含敏感数据
				
				
	- fs模块
		- 在Node通过fs模块来对系统中的文件进行操作，fs模块是node中已经继承好了，不需要在使用npm下载，直接引入即可
		- 引入fs
			var fs = require("fs");
		- fs模块中的大部分操作都提供了两种方法，同步方法和异步方法
			同步方法带sync
			异步方法没有sync，都需要回调函数
			
		- 写入文件
			1.同步写入
			2.异步写入
			3.简单写入
			4.流式写入
			
		- 读取文件
			1.同步读取
			2.异步读取
			3.简单读取
			4.流式读取
			
		- 方法
			- 打开文件
				fs.open(path, flags[, mode], callback)
					- 回调函数的参数①err 错误对象，如果没有错误则为null ②fd 文件的描述符
				fs.openSync(path, flags[, mode])
					- path 要打开文件的路径
					- flags 打开文件要求操作的类型
						r 只读的 w可写的 a追加
					- mode 设置文件的操作权限，一般不传

			- 读写文件
				fs.write(fd, string[, position[, encoding]], callback)
					- 回调函数的参数①err ②written被写入多少字节 ③写入的内容 
				fs.writeSync(fd, string[, position[, encoding]])
					- fd 文件的描述符，需要传入要写入文件的描述符
					- string 要写入的内容
					- position 写入的起始位置 不管
					- encoding 编码类型 默认utf-8
				fs.read(fd, buffer, offset, length, position, callback)
				fs.readSync(fd, buffer, offset, length, position)
				
			- 关闭文件
				fs.close(fd,callback)
				fs.closeSync(fd);
					- fd 文件的描述符，需要传入要关闭的文件的描述符
			- 简单文件读取和写入
				fs.writeFile(file, data[, options], callback)
				fs.writeFileSync(file, data[, options])
					- file 要操作的文件路径
					- data 要写入的数据
					- options 选项，可以对写入进行一些设置
				fs.readFile(path[, options], callback)
				fs.readFileSync(path[, options])
				
				
			- 流式文件读取和写入
				- 流式读取和写入适用于一些比较大的文件
					var ws=fs.createWriteStream(path[, options])
					var rsfs.createReadStream(path[, options])
				- 将可读流中的内容，直接输出到可写流
					rs.pipe(ws);
			- 其他操作
				验证路径是否存在 
				C fs.exists(path，callback) C fs.existsSync(path)
				获取文件信息 
				C fs.stat(path, callback) C fs.statSync(path)
				删除文件 
				C fs.unlink(path, callback) C fs.unlinkSync(path)
				列出文件 
				C fs.readdir(path[, options], callback) C fs.readdirSync(path[, options])
				截断文件 
				C fs.truncate(path, len, callback) C fs.truncateSync(path, len)
				建立目录 
				C fs.mkdir(path[, mode], callback) C fs.mkdirSync(path[, mode])
				删除目录 
				C fs.rmdir(path, callback) C fs.rmdirSync(path)
				重命名文件和目录 
				C fs.rename(oldPath, newPath, callback) C fs.renameSync(oldPath, newPath)
				监视文件更改写入 
				C fs.watchFile(filename[, options], listener)


8.各种第三方包及其用法

	mime 包
		-mime.lookup(url)   
			通过url获取文件的后缀名用来设置响应头类型



	mongoose 包
		- mongoose.connect('mongodb://数据库IP地址：端口号/数据库名',{useMongoClient:true})  
			链接mongoose数据库,如果端口号默认是27017，则可以不用填写
		- mongoose.connection.once("open",function () {
    								console.log("数据库链接成功!");
								});
		- mongoose.connection.once("close",function () {
    								console.log("数据库断开成功!");
								});
			监听服务器的链接状态
		- var Schema=mongoose.Schema;
		  var stuSchema=new Schema({
    						name:String,
   						age:Number,
   						gender:{
     					   	type:String,
        					default:"female"
    						},
    						address:String
						});
			创建Schema(模式)对象
		-var StuModel=mongoose.model("students",stuSchema);
			创建Model，Model表示数据库里面的集合，2个参数，第1个表示集合的名字，第2个表示用哪个对象来约束集合
		- 查询Model.find(conditions,[projection],[options],callback)
		     Model.findById(id,[projection],[options],callback)
		     Model.findOne(conditions,[projection],[options],callback)
				conditions 查询的条件
				projection 投影  传统{name:1,_id:0}  另一种"name -_id_"
				options 查询选项(skip  limit )
		- 修改 Model.update(conditions ,doc ,[options] ,callback)
		      Model.updateMany(conditions ,doc ,[options] ,callback)
		      Model.updateOne(conditions ,doc ,[options] ,callback)
		- 删除 Model.remove(conditions,callback)
		       Model.deleteOne(conditions,callback)
	               Model.deleteMany(conditions,callback)
		- 统计 Model.count(conditions,callback)
		- 处理id用作为条件    处理id可以直接用id更新
    		       var sid=mongoose.Types.ObjectId(req.body.id);
	
	md5-node模块
		- 1安装 npm install md5-node --save
		- 2引入 var md5=require("md5-node")
		- 3使用 md5(123456);
	

	express框架
		- var express=require('express');  /*引入 express*/ 
		- var app=new express(); /*实例化 express 赋值给 app*/ 
		- app.get("网址",function(req,res){   });   当用 get 请求访问一个网址的时候，做什么事情：
		  app.post("网址",function(req,res){   });  当用 post 访问一个网址的时候，做什么事情： 
		  app.put('/user', function (req, res) {   res.send('Got a PUT request at /user'); }); // user 节点接受 PUT 请求 
		  app.delete('/user', function (req, res) {   res.send('Got a DELETE request at /user'); }); // user 节点接受 DELETE 请求 
			简单静态路由配置
		- app.get("/user/:id",function(req,res){ var id = req.params["id"]; res.send(id); }); 
			动态路由配置以及获取动态get传值 
		- /news?id=2&sex=nan 
		  app.get('/news, function(req, res) {    console.log(req.query); });  路由里面获取 Get 传值
		- 托管静态文件
		  app.use(express.static("public"));  给public目录下面的托管静态文件
		  匹配虚拟目录的静态web服务
		  app.use("/status",express.static("public"))
		- 中间件：就是匹配路由之前和匹配路由之后做的一系列操作
		  1.应用级中间件 表示匹配任何路由
			app.use(function (req, res ,next) {
								console.log(new Date());
								next();//路由继续向下匹配
							})
		  2.路由中间件    next()路由继续向下匹配
			app.get("/news",function (req, res,next) {
    									console.log("这是路由中间件");
   									next();
								})
			app.get("/news",function (req, res) {
    									res.send("这是路由中间件news2");
								})
		  3.内置中间件 托管静态页面
			app.use(express.static("public"));
		  4.错误处理中间件
			app.use(function (req, res) {
    							res.status(404).send("404错误 表示路由没有匹配到");
						   })
		-  登陆成功直接跳转页面res.redirect("/product")
		- 模块化路由
			1.后台路由引入express模块
			var express=require("express");
			2.使用express.Router类创建模块化、可挂载的路由句柄
			var router=express.Router();
			3.后台配置路由
			router.get("/login",functiong(req,res){
				res.send("登陆!");
			}) 
			4.暴露后台模块
			module.exports =router;
			5.主程序引入后台模块
			var index=require("");
			6.主程序使用后台路由
			app.use("/",index);


		
		 
	express框架中的ejs包使用
		- 安装 npm install ejs --save
		- app.set("view engine","ejs");  //配置ejs模板引擎
		- ejs前台模板文件默认目录放在views下  可以通过app.set("views",_dirname+"/目录名"); 来重新指定新的ejs模板地址
		- var arr =["111","222","333"]
  		  res.render("index" ,{list:arr})//ejs渲染模板 第1个参数为在view下需要渲染的模板引擎名字，第2个参数为需要渲染到前台的数据
		- 引入外部公共的ejs文件<%- include ../public/header.ejs  %>
		- 注册html模板引擎
		  app.engine("html",ejs._express);
		  将模板引擎换成html
		  app.set("view engine","html");  然后就可以创建后缀名为html的模板引擎了
		- 设置全局变量 可以在任何页面显示
		  app.locals["username"]=req.session.userinfo.username

	express框架中获取post传值的body-parser包
		- 引入模块
			var bodyParser=require("body-parser");
		- 配置
			app.use(bodyParser.urlencoded({ extended: false }));
			app.use(bodyParser.json());
		- 获取post传值
			req.body

	multiparty模块解决图片上传以及post提交表单数据问题
		- 安装 npm install multiparty --save
		- 引入 var multiparty=require("multiparty");
		- 使用 var addProduct=new multiparty.Form();
		       addProduct.uploadDir="upload-img";  //上传图片保存地址
		       addProduct.parse(req,function(err,fields,files){
					console.log(fields);  //表单提交过来的文字信息
					console.log(files);  //表单提交过来的图片信息
			})



		
	cookie  - cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名的时候共享数据。
		- 1.安装 cnpm instlal cookie-parser --save
		  2.引入 var cookieParser = require('cookie-parser');
		  3.设置中间件
		  app.use(cookieParser());
		  4.设置 cookie   第1个参数是cookie的名字 第2个是cookie的值 第3个是属性
		  res.cookie("name",'zhangsan',{maxAge: 900000, httpOnly: true}); 
		  HttpOnly 默认 false 不允许 客户端脚本访问
		  5.获取 cookie
		  req.cookies.name
		- 第3个参数cookie的属性
		  属性说明
			- domain: 域名   例如：.aaa.com  多个2级域名共享cookie信息
			  C:\Windows\System32\drivers\etc  下的hosts 设置本地的ip域名
			- Expires： 过期时间（秒），在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday,
			- res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly:true });
			- maxAge： 最大失效时间（毫秒），设置在多少后失效
			- secure： 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效
			- Path： 表示 在哪个路由下面可以访问cookie ，如 path=/。如果路径不能匹配时，浏览器则不发送这个 Cookie
			- httpOnly：是微软对 COOKIE 做的扩展。如果在 COOKIE 中设置了“httpOnly”属性为true，则通过程序（JS脚本、applet 等）将无法读取到COOKIE 信息，防止 XSS 攻击产生
			- singed：表示是否签名cookie, 设为true 会对这个 cookie 签名，这样就需要用res.signedCookies 而不是 res.cookies 访问它。被篡改的签名 cookie 会被服务器拒绝，并且 cookie值会重置为它的原始值
		        - 加密cookie
			1.配置中间件的时候需要传参
			app.use(cookieParser('123456')); 123456其实可以随便传入
		 	2. 设置 cookie  的时候配置 signed为true
			res.cookie('userinfo','hahaha',{domain:'.ccc.com',maxAge:900000,httpOnly:true,signed:true});
			3.signedCookies  调用设置的 cookie
			console.log(req.signedCookies);
	session - session  （包名叫express-session）是另一种记录客户状态的机制，不同的是 Cookie  保存在客户端浏览器中，而 session  保存在服务器上。
		  session 与cookie的区别 关闭浏览器记录会清空
		  1.安装 express-session
		  2.引入 express-session   var session=require("express-session");
		  3.设置官方文档提供的中间件
			app.use(session({
    					secret: 'keyboard cat',
   					resave: false,
    					saveUninitialized: true
					}));
		  4.设置session   req.session.urseinfo="帮办";
		  5.获取session   req.session.urseinfo 
		  6.退出session   req.session.cookie.maxAge=0; 重新设置 cookie 的过期时间  
		                  req.session.destroy(function(err) { })   销毁登陆
		- session设置中间件时候的一些属性
			secret 可以随便设置加密,一个 String 类型的字符串，作为服务器端生成 session 的签名。
			name  返回客户端的 key 的名称，默认为 connect.sid,也可以自己设置。
			resave 强制保存 session 即使它并没有变化,。默认为 true。建议设置成 false。
			saveUninitialized  强制将未初始化的 session 存储。当新建了一个 session 且未设定属性或值时，它就处于未初始化状态。在设定一个 cookie 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）。建议手动添加。
			cookie 设置返回到前端 key 的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。
			rolling  在每次请求时强行设置 cookie，如果将其设置为true,这将重置 cookie 过期时间（默认：false）
		- 将session 的信息保存到数据库
		  1.需要安装 express-session 和 connect-mongo 模块
		  2.引入模块
			var session = require("express-session");
			var connectMongo=require("connect-mongo")(session);
		  3.配置中间件
			app.use(session({
    					secret: 'this is string key',
    					name:"session_id",
    					resave: false,
    					saveUninitialized: true,
    					cookie:{maxAge:1000*60*30},
    					rolling:true,
    					store:new connectMongo({
        							url:"mongodb://127.0.0.1:27017/test",  //服务器地址
        							touchAfter:24*3600  //通过设置touchAfter：24 * 3600来设置touchAfter：24 * 3600，在24小时内只会更新一次，无论请求的数量是多少（除了那些会改变会话数据的数据）
    								})

				}));
		
		
 
 
 



	
9.状态码
		- 1xx 请求正在处理
		- 2xx 正常处理完成
			200 OK 请求成功
		- 3xx 重定向
			301 Moved Permanently 永久重定向
			302 Found 临时重定向  服务器的负载均衡
			304 本次获取的内容是读取缓存中的数据
		- 4xx 客户端错误
			400 Bad Request 语法错误，客户端传递给服务器端的参数出现错误
			401 Unauthorized 权限未认证
			403 Forbidden 禁止访问
			404 Not Found 资源未找到
		- 5xx 服务器端错误
			500 Internal Server 未知的服务器错误
			503 服务器已经超负荷
10.http模块	
		-function sverve(res,req){
					 res.writeHead(404 ,{"Content-Type":"text/html; charset=utf-8"});//响应头
					 res.write(data404);
					 res.end();
				}
		-var sverver=http.createServer(sverve)  创建服务器
		-server.listen(8055 );   监听端口

		-http 常用方法
			1. var server = http.createServer(function(request,response){})  
				* 创建一个服务,变量server就是我们创建出来的那个服务,当客户端向服务器端的当前服务(端口80)发送一个请求，并且当前服务已经成功接收到这个请求后执行回调函数
				* request(请求)：存放的是所有客户端的请求信息，包含客户端通过问号传参的方式传递给服务器的数据内容
					* request.url：如果用户输入http://127.0.0.1/index.html?name=zhufeng&age=7 则通过request.url获取到/index.html?name=zhufeng&age=7
				* response(响应)：提供了向客户端返回内容和数据的方法
					* response.writeHead(200,{'content-type':'text/html;charset = utf-8;'}); 设置响应头。
					* response.write(); 向客户端返回内容
					* response.end(); 告诉服务器响应结束了
			2. server.listen(80,function(){	     为这个服务监听一个端口80，当端口号监听成功之后执行回调函数.
				//当端口号监听成功之后执行
				console.log ("server is create success,listening on 80 port!");
			   })

11.url模块(url/uri/urn)	
		- uri = url + urn 统一资源标识符(统一资源信息)
		- URL统一定位符
			* http://user:pass@v.qq.com:80/index.html?name=zhufeng&age=7#bbs
			* http：传输协议 -->客户端和服务器端的内容和服务区端传递给客户端的内容都是通过HTTP传输协议进行传输的(我们把HTTP理解为快递小哥)
			* user: 用户名
			* pass：密码
			* v.qq.com：域名
			* 80：端口号
			* index.html：请求资源文件名
			* ?name=zhufeng&age=7：url问号传参 -->客户端传递给服务器的内容
			* #bbs：URL的hash(锚点定位)
		- 传输协议：
			* http：超文本传输协议，除了传输文本外还可以传输其他的东西，例如：XML等
			* https：更加安全的http
			* ftp：文件传输协议(应用于把项目源文件传递到服务器上)
			* 一般默认端口http找80，https找443，ftp找21端口
		- 分布图解析请访问 http://nodejs.cn/api/url.html#url_constructor_new_url_input_base
		- var urlObj=url.parse(req.url,true);
			表示将请求转化为对象，第1个参数为请求url 第2个参数true表示将query查询字符串转换为对象
		- var pathname=urlObj.pathname
			获取路径名
		- url模块常用方法
			1. url.parse (url , true); 解析url地址，传入true将query字符串转换为对象
				例如：var str = "http://www.baidu.com:80/index.html?name=bbdeng&age=24#bbs";解析这个地址
				Url {
					protocol: 'http:',
					slashes: true,
					auth: null,
					host: 'www.baidu.com:80',
					port: '80',
					hostname: 'www.baidu.com',
					hash: '#bbs',
					search: '?name=bbdeng&age=24',
					query: { name: 'bbdeng', age: '24' },
					pathname: '/index.html',
					path: '/index.html?name=bbdeng&age=24',
					href: 'http://www.baidu.com:80/index.html?name=bbdeng&age=24#bbs' 
				}

12.buffer 
		3种构建buffer的方法
	      - var buf1=new Buffer(3);
		buf1[0]=0x61;buf1[1]=0x62;buf1[2]=0x63;
	      - var buf2=new Buffer([0x61,0x62,0x63]);
	      - var buf3=new Buffer("abc");
		buf1==buf2==buf3

13. http报文
	- 客户端传递给服务器的内容 和 服务器传递给客户端的内容 都属于HTTP的报文
	- 起始行：请求起始行 响应起始行
	- 首部：请求首部 响应首部 通用首部(请求和响应都有的) 自定义首部
	- 主体: 请求主体 响应主体
	- 详解
		- Request Headers (view sourse)
		Get /index.html HTTP/1.1 ->请求起始行 HTTP method请求方式、请求的地址、使用的HTTP传输协议的版本号
		请求首部：客户端会把一些信息放在请求首部中传递给相关服务器端，服务器端就可以在请求首部中获取到相关信息
		Host: www.baidu.com
		Connection: keep-alive
		Pragma: no-cache
		Cache-Control: no-cache
		Accept: text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01
		X-Requested-With: XMLHttpRequest
		User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36
		Referer: https://www.baidu.com/
		Accept-Encoding: gzip, deflate, br
		Accept-Language: zh-CN,zh;q=0.9,en;q=0.8

		- Response Headers (view sourse)
		HTTP/1.1 200 OK ->响应起始行：HTTP版本号、响应的状态码、状态码的说明
		响应首部：服务器端传递给客户端的一些信息可以放在响应首部中，客户端可以在响应首部中获取到服务器的相关信息(服务器设置 客户端获取)
		Cache-Control: private
		Connection: Keep-Alive
		Content-Type: baiduApp/json; v6.27.2.14; charset=UTF-8
		Date: Tue, 15 May 2018 07:06:43 GMT	->服务器当前本次响应的时间(GMT服务器时间格林尼志时间)
		Expires: Tue, 15 May 2018 08:06:43 GMT  ->响应内容的格式和编码
		Server: suggestion.baidu.zbb.df
		Content-Length: 95
		
		- Response 响应主体 
		服务器传递给客户端的数据内容都在响应主体中，客户端可以在响应的主体中获取到这些内容(服务器端设置 客户端获取)

		- Request Payload请求主体
		客户端传递给服务器端的数据内容可以放在请求主体中传递给服务器，服务器可以在请求主体中获取到传递进来的内容

		客户端传递给服务器端数据：
		1. 请求URL后面问号传参的方式传递给服务器
		2. 设置请求的首部
		3. 设置请求主体，把传递给服务器的内容放在请求主体中传递给服务器

		服务器端传递给客户端数据：
		1. 设置响应头信息
		2. 设置响应主体内容

14. Ajax:async javascript and xml 异步的JS和XML
	* xml：可扩展的标记语言(在xml文件中使用的标签都是自己扩展的)，利用自己扩展的有规则的标记来存储相关的数据
	* Ajax的作用：客户端JS中的方法，用来想服务器端发送请求(还可以传递给服务器端数据)，然后把服务器端返回的内容获取到(运行在客户端的浏览器中)
	- Ajax 四步：
	1.创建一个Ajax对象(IE6以下不支持)
	var xhr = new XMLHttpRequest();
	2.发送前的基本信息配置：
		配置请求方式(get、post、put、delete、head...)
		打开一个URL地址(配置向一个服务器地址发送请求)
		同步还是异步(true是异步，false是同步 默认true)
		[username]向服务器提供请求的用户名
		[userpass]向服务器提供请求的用户密码，这2个值一般不写，只有服务器做了安全的限制，只允许特定的用户访问的话，我们才传递过去
	xhr.open("get","/data.txt",false,[username],[userpass]);
	3.给onreadystatechange这个事件绑定一个方法，监听状态的改变(只要状态改变，就会触发回调)
		0 UNSEUT 当前的请求还没有发送
		1 OPENED URL地址已经打开(发送前的参数配置已经完成)
		2 HEADERS_RECEIVED 响应头信息已经接收
		3 LOADING 主要返回的内容正在服务器端进行准备处理
		4 DONE 响应主体的内容已经成功返回到客户端
	xhr.onreadystatechange = function () {
		if (xhr.readyState === 4 && /^2\d{2}$/.test(xhr.status)){
			var data = xhr.responseText;
		}
	};
	4.发送请求：参数是请求主体中传递给服务器的内容
	xhr.send(null);

15. 同源和非同源
	- 区分同源和非同源：
	* 用当前页面的地址 && 数据请求的接口地址比较
	1. 协议
	2. 域名或者IP
	3. 端口号
	以上三部分完全相同属于同源策略，使用ajax技术获取数据，只要有一个不一样，就属于非同源，我们一般使用JSONP获取数据。
	
	JSONP	jsonp请求一定需要对方的服务器做支持才可以
		JSONP的原理：在script的世界中，没有同源跨域这一说，只要是src属性中是一个合法的地址，script都可以把对应的内容请求回来
		JSONP就是利用以上原理：
			1. 我们首先把需要请求数据的，那个跨域的api数据接口的地址，赋值给script的src
			2. 把当前页面中的某一个函数名当做参数值传递给需要跨域请求数据的服务器(url问号传参?callback=fn)
			3. 腾讯服务器接受到请求后，需要进行特殊的处理：把你传递进来的数据名和它需要给你的数据拼接成一个字符串
			例如：我们传递进去的函数名是fn，它准备好的数据是'fn([{"name":"zhufeng"}])' ->'我传递的函数名(需要给我们的数据)'
			4. 最后腾讯的服务器把准备的数据通过HTTP协议返回给我们客户端，客户端发现其实就是让我们的fn执行，而且还给fn传递了一堆数据，哪些数据就是我们想要的
			 











































